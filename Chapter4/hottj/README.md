 # 관계형 데이터베이스

# 데이터베이스 제어 기법

- 1:M
    - 부모 자식 관계
    - 관계라는 것은 참조 무결성을 위해 PK와 FK의 관계를 뜻한다
    - 부모가 없는 자식을 디비에 넣으려고 하면 에러남. FK를 보고 찾아가서 부모에 PK가 없다면 에러!

- M:N
    - 비지니스 관계
    - 서로가 1:M
    - 내가 수학을 듣고, 영어를 들을 수 있다. (나의 입장) 그런데 나의 테이블에서 내가 두개를 수강하니 내 PK 중복 발생해버린다
        - 이는 반대쪽 테이블도 마찬가지. 수학은 a, b 둘다 들을 수 있다. 이러면 과목 pk가 중복 발생
        - 이를 어떻게 해결? 
    - 학생이 과목을 수강한다. 수강 테이블로 풀어쓴다. 학생과 과목은 연관성이 없다. 그냥 서로 각각의 객체들이다. 이게 수강한다(동사)라는 비지니스 관계가 생길때 관계가 맺어진다.
        - 즉 M:N은 둘의 테이블을 억지로 관계를 맺으려고 해서 문제가 발생하는 것
    - 학생, 과목은 마스터 테이블. 도메인 크기가 거의 그대로. 늘고 줄어드는게 적다.
    - 수강 테이블은 학생id, 과목id 라는 fk를 갖고 있다. 이는 중복이 되도 된다.
    - 비지니스 관계 테이블은 수강뿐만 아니라 다른 어떤 관계 동사가 생길 수 있다.
    - 수강 테이블도 pk를 가져야한다. 그래야 제대로 된 테이블이다. 테이블을 해석할 수 있어야 제대로 설계된 디비다.
        - 수강 테이블도 pk를 가지기 때문에 마스터 테이블로서 다른 테이블과 m:n 관계를 맺을 수 있다.
    - (학생id + 과목id) 두개를 묶어서 pk로 만들 수 있다.
        - 예로 3번이 수학을 수강했다는 테이블이 기존에 있을 경우, 3번이 수학을 또 수강할 때 pk 중복이 일어나 막을 수 있다.
        - 하지만 위처럼 pk를 선언하지 않고 그냥 수강 테이블에 1,2,3...처럼 Pk를 선언할 경우, 위의 현상은 중복이 일어나 막을 수 없게 된다.
            - 한 학기에 동일 과목을 두번 수강하는 건 오류. 근데 이게 오류가 아닐 경우도 있을 수 있다.
            - 내가 커피를 한잔 사고, 다시 또 한잔사고 싶을때 이게 불가능하면 말이 안되는것!!!!
            - 즉, 중복을 허용할때는 pk를 독립시키고 허용하면 안될때는 pk를 독립시키지 않으면 된다.
        - 만약 fk가 너무 많아서 중복을 허용하지 않고자 fk들을 합쳤을 경우, 이는 너무 길어져서 불편하다.
            - 이를 해결하기 위해 대체키를 만들어서 이를 Pk로 사용해준다. 

- 1:1
    - 신랑 신부 관계
    - 서로가 부모이므로, 지울 수 없다. 
    - 우리는 본질적으로 하나다. 내 pk가 1이면 상대방 pk도 1이다.
    - 공통 분모가 있고, 세부정보가 다르다면 1:1로 해결!!!
        - 하나의 테이블로 만들기보다는 각각 나눠서 테이블명으로 select 해주는것이 좋다. 각각의 객체끼리 다른 마스터 테이블과 관계를 맺기 용이하므로

## 트랜잭션
* 데이터베이스의 상태를 변화시킬 때 한 번에 수행되어야하는 하나의 `원자적인 작업의 단위`
* Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

## 트랜잭션-병행제어
* 동시에 여러개의 트랜잭션을 병행 수행할 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 `트랜잭션 간의 상호작용을 제어`하는 것
  * 병행성 : 트랜잭션을 동시에 `인터리빙`하게 실행되는 것
  * 인터리빙 : 트랜잭션이 번갈아가며 조금씩 처리를 수행하는 것
* 목적
  * DB의 공유도 최대화
  * 시스템 활용도 최대화
  * 응답 시간 최소화
  * 단위 시간당 트랜잭션 처리 건수 최대화
  * DB의 일관성 유지
* 병행제어의 필요성
  * 갱신 분실
    * 같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 사라짐
  * 모순성
    * 동시에 같은 데이터를 갱신할 때, 데이터의 상호 불일치가 발생
  * 연쇄 복귀
    * 트랜잭션 중 하나에 문제가 생겨 롤백되는 경우, 다른 트랜잭션들도 함께 롤백
  * [참고](https://eastroot1590.tistory.com/entry/DBMS%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B3%91%ED%96%89-%EC%88%98%ED%96%89%EA%B3%BC-%EB%B3%91%ED%96%89-%EC%A0%9C%EC%96%B4)

* 로킹
  * 하나의 트랜잭션이 사용하는 DB내의 data를 다른 트랜잭션이 접근하지 못하게 하나의 트랜잭션 실행될때는 락을 설정하여 다른 트랜잭션이 접근하지 못하도록 `잠근후 실행, 실행 완료 후 언락`
  * 테이블, 속성, 튜플 단위로 락 설정

* 교착상태(데드락)
  * 락 상태가 오래 유지되어 다른 트랜잭션들이 더 이상 진행하지 못하고 무한정 대기
  * 해결법
    * 공유락 : 사용중인 데이터를 다른 트랜잭션이 읽기 허용, 쓰기 불허용으로 설정
    * 베타락 : 사용중인 데이터를 다른 트랜잭션이 읽기, 쓰기 모두 불허용

* 타임스탬프
  * 병행제어의 또 다른 기법. `각 트랜잭션이 데이터에 접근할 시간을 미리 지정` 그 시간의 순서에 따라 순서대로 데이터에 접근하여 수행. 제한적인 시간이 존재하므로 데드락 발생하지 않음

## ACID
* 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
* `Atomicity(원자성)`: `모든 작업이 반영되거나 모두 롤백되는 특성`입니다.
* `Consistency(일관성)`: 데이터는 `미리 정의된 규칙에서만 수정이 가능한 특성`을 의미합니다.
* `Isolation(고립성)`: A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.
* `Durability(영구성)`: 한번 반영(커밋)된 트랜젝션의 내용은 `영원히 적용`되는 특성을 의미합니다.

## 무결성 제약조건
* 개체 무결성: 주키는 null, 중복 값을 가질 수 없음
* 참조 무결성: 외래키는 null이거나 참조 릴레이션의 기본키 값과 동일해야 함

# 프로세스 vs 스레드

![자바스레드](https://user-images.githubusercontent.com/47052106/113518897-14cc6400-95c4-11eb-8917-cfb45ad55306.png)

- 스레드는 스택영역을 스레드의 개수만큼 분할하는 것이다. 또한 각각의 스레드는 다시 스태틱영역, 스택영역, 힙영역을 가지게 된다.
- 스택영역이 분할되므로 스레드 간의 스택영역을 침범 할 수는 없지만 큰 측면에서 봤을 때 결국 자바 메모리의 스태틱영역과 힙영역은 공유 할 수 있다!

## 멀티프로세스 vs 멀티스레드

- 멀티 프로세스(Multi Process)
    - 하나의 프로세스가 다른 프로세스의 T메모리 영역을 절대 침범 할 수 없는 메모리로써 안전한 구조이지만, 그만큼 메모리 사용량을 크다!
- 멀티 스레드(Multi Thread)
    - 스택영역이 분할되어 하나의 스레드에서 다른 스레드로 접근 할 수는 없지만 스태틱 영역과 힙 영역은 공유해서 사용 할 수 있다. 따라서 멀티 프로세스 대비 메모리를 적게 사용 할 수 있는 구조이다.

## 서버 프로그래밍에서 Servlet은 요청 당 스레드를 생성

- Servlet 과 CGI??
    - 요청 당 스레드를 생성 => Servlet
    - 요청 당 프로세스 생성 => CGI
- [CGI](https://jinbroing.tistory.com/205)
- [Servlet](https://mangkyu.tistory.com/14)
- [웹서버와 WAS](https://www.youtube.com/watch?v=NyhbNtOq0Bc)

- 스레드가 Critical Section을 접근하는 것에 대한 문제를 해결해야 한다.

# 쿠키와 세션
- 쿠키
    - 사이트를 방문하고 이용할 때 브라우저에 저장되는 내용. 브라우저는 내 컴퓨터에 있는 거니까 내가 갖고 있는 정보다.
    - 내가 임의로 고치거나 지울 수 있고, 남이 훔쳐보거나 가져갈 수 있다.
    - 로그인창의 아이디를 자동완성하거나, 공지 메시지를 하루 안보기 하거나 쇼핑몰 사이트에서 로그인 안 한 상태로 물건을 장바구니의 담는 등 사용자의 편의를 위하되, 지워지거나 조작되거나 가로채이더라도 큰 일은 없을 수준의 정보들을 브라우저에 저장하는데 사용
- 세션
    - 세션을 사용하는 사이트에 접속하면 서버에서는 사용자를 구분하기 위한 기한이 짧은 임시 키 하나를 브라우저에 보내서 쿠키로 저장
    - 사용자의 중요 정보들은 서버의 메모리나 데이터베이스에 저장
    - 브라우저가 이 사이트의 페이지들에 접속할 때 마다 http 요청에 이 키가 담긴 쿠키를 실어서 전송하고, 서버는 그 키를 보고 인증된 사용자임을 인식해서 사용자의 정보들을 가공해서 응답으로 보내줌
    - 네이버에 한번 로그인한 다음 네이버의 다른 페이지들을 이용할 때마다 새로 로그인할 필요가 없는 것이, 쿠키와 세션의 조합으로 우리가 네이버에 로그인해있다는 걸 네이버 서버가 인지하고 있기 때문이다. 만약, 쿠키의 정보를 모두 지우면 로그아웃된다. 서버에서는 세션에 나의 로그인 정보를 갖고 있지만 그게 내꺼라는 걸 증명할 세션 아이디가 내 쿠키 보관함에서 지워졌기 때문이다.
    - 서비스 제공자가 직접 관리해야하고, 노출되어서는 안 될 정보들은 세션으로 서버 안에서 다뤄짐
    - 세션을 남발하면 접속자가 많을 때 서버에 부하가 걸림
- 캐시
    - 가져오는 데 비용이 드는 데이터를 한 번 가져온 뒤에는 임시로 저장
    - 웹 캐시는, 이미지 등의 정보를 불러올 때 데이터 사용량도 발생하고 시간도 들기 때문에 사용자가 여러 번 방문할 법한 사이트에서는 한 번 받아온 데이터를 사용자의 컴퓨터 또는 중간 역할을 하는 서버에 저장해둠.
