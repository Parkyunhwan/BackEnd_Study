# WEEK1

## 1. 객체 지향 설계 원칙
- **개념**
    - 특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생
    - 객체 내부에 자료형과 함수가 같이 존재
    - 재사용성 높고 내부 동작을 몰라도 사용할 수 있기 때문에 생산성이 높음
    - 객체 단위로 코드가 나눠져 작성되기 때문에 유지 보수에 용이
    <br>
    </br>

- **특징**
	- 추상화
    	- 공통적인 속성이나 기능을 추출
    	- 비슷한 객체가 추가될 경우 다른 곳의 코드 수정할 필요 없이 추가로 만들 부분만 새로 생성해주면 됨
	- 캡슐화
    	- 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶음
    	- 정보 은닉을 활용하여 낮은 결합도를 유지하게 함
    	- 코드를 수정했을 때 다른 곳에 미치는 영향 최소화
	- 상속
    	- 상위 클래스의 멤버 변수나 메소드를 물려 받아 재사용
    	- 코드 재활용으로 인해 생산성이 높고 유지 보수 좋음
	- 다형성
    	- 같은 모양의 함수가 상황에 따라 다르게 동작
    	- 오버 로딩 : 함수의 이름은 같지만 매겨변수 수, 타입 등을 달리해서 다르게 사용
    	- 오버 라이딩 : 상위 클래스의 메소드를 재정의
    <br>
    </br>

- **객체지향적 설계 원칙**
  - SRP(Single Responsibility Principle, 단일 책임 원칙)
    - 클래스는 단 하나의 책임을 가져야 한다.
  - OCP(Open-Closed Principle, 개방-폐쇄 원칙)
    - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  - LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  - ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  - DIP(Dependency Inversion Principle, 의존 역전 원칙)
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    <br>
    </br>

## 2. HTTP Method
  - **개념**
    - 클라이언트가 웹 서버에게 사용자 요청의 목적/종류를 알리는 수단
    <br>
    </br>

  - **종류**
    - Get : 정보를 요청하기 위해 (read)
    - Post : 정보를 입력하기 위해 (create)
    - Put : 정보를 업데이트하기 위해 (update)
    - Delete : 정보를 삭제하기 위해 (delete)
    <br>
    </br>

- **GET과 POST 차이**
    - GET은 주소 뒤에 쿼리 스트링이 그대로 전달되어 보안성이 떨어지고 전송속도는 빠르다.
    - 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
    - POST는 주소가 전달될 때 인코딩하여 전달되어 보안성이 높지만 전송 속도가 느리다.
    - 주로 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용
    <br>
    </br>

- **PUT과 PATCH 차이**
    - PUT은 요청된 자원을 수정할 때, 자원 내 필드 전체를 수정할 때 사용
    - PATCH는 자원 내 필드 일부를 수정할 때 사용
    <br>
    </br>

## 3. 선택 정렬

- **선택 정렬이란?**
    - 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

    1.  주어진 배열 중에 최소값을 찾습니다.
    2. 그 값을 맨 앞에 위치한 값과 교체합니다. (pass)
    3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체합니다.
    <br>
    </br>

- **선택 정렬의 시간 복잡도**
  -  시간 복잡도 최선, 평균, 최악 : O(n^2)
     -  첫번 째 회전 때 비교 횟수 : 1~(n-1)
     -  두번 째 회전 때 비교 횟수 : 2~(n-2) 
    <br>
    </br>

## 4. 삽입 정렬

- **삽입 정렬이란?**
    - 1번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입

    1. 정렬은 2번째 위치(index)의 값을 temp에 저장합니다.
    2. temp와 이전에 있는 원소들과 비교하며 삽입해나갑니다.
    3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복합니다.
    <br>
    </br>

- **삽입 정렬의 시간 복잡도**
    - 시간 복잡도 최선 : O(n)
    - 시간 복잡도 평균, 최악 : O(n^2)
    <br>
    </br>

## 5. 거품 정렬

- **거품 정렬이란?**
    - 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘

    1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환합니다.
    2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외됩니다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어납니다.
    <br>
    </br>

- **거품 정렬의 시간 복잡도**
    - 시간 복잡도 최선, 평균, 최악 : 정렬이 되어 있던, 되어 있지 않던 두 개의 원소를 배열 끝까지 비교하므로 O(n^2)
    <br>
    </br>