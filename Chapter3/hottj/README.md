# 데이터베이스

## 정의
- 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합

## 사용 이유

- 파일 시스템의 문제점을 해결하기 위해 사용
- 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
- 데이터 중복, 비일관성, 검색 등의 문제 존재 -> 중복 최소화, 보안성, 계속적 변화에 대한 적응
- DB는 원자적 갱신, 동시성 제어, 데이터 보호, 백업 및 회복 등의 여러 데이터 관리 기능을 두어 데이터 관리를 편하게 하기 때문에 사용

## 테이블
- 행과 열로 이루어진 데이터의 집합

## 도메인
- 데이터베이스 필드에 채워질 수 있는 값들의 집합

## 행
- 테이블을 구성하는 데이터 셋으로 튜플이나 레코드라고 불림

## 열
- 테이블을 구성하는 데이터 셋으로 속성이라고 불림

## 뷰
* 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용하게 하여 특정 속성을 숨김
* 메모리에 물리적으로 존재하지 않는 가상 테이블

## 스키마와 테이블의 차이
* `스키마는 테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더, 데이터의 구조와 구성을 설명
* `테이블은 행과 열로 구성된 데이터 집합`

## 후보 키
* 릴레이션을 구성하는 속성들 중에서 Tuple을 `유일하게 식별`할 수 있는 속성들의 부분 집합
* null 인정
* 유일

## 주 키
* 후보 키 중에서 선택한 Main Key
* notnull
* 유일

## 외래 키
* 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
* 참조되는 릴레이션의 `주 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
* 사용 이유: 테이블을 연결, 중복 방지
  * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거

# 데이터베이스 인덱스

## Index를 사용하는 이유와 장점 및 단점
* 인덱스는 추가적인 쓰기와 저장 공간 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
* 테이블 내의 `칼럼의 값(Key)`과 해당 `Key의 레코드가 저장된 주소`를 `키와 값의 쌍으로 정의`
* 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음

## Index 자료구조
* B 트리

  ![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
  * 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
  * 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
  * Branch 노드: Key와 Data 저장
* B+ 트리

  ![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)
  * B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가시킨 자료구조
  * B 트리보다 풀 스캔 빠름
  * Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능
  * Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결(부등호를 사용한 순차 검색에 유용)

* 해시 테이블
  * 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
  * O(1)로 매우 빠름
  * 인덱싱에선 부등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐
  * `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음

## Clustered-Index vs Non-Clustered-Index
* Non-Clustered Index
  * 물리적으로 재배열 하지 않는다
  * 인덱스 키 값에는 해당 데이터에 대한 포인터가 존재
    * 인덱스의 구조는 데이터 행과 독립적
    * 한 테이블에 여러 개 생성 가능
  * 리프노드에 있는 테이블 번호를 통해 해당 테이블로 가서 찾고자하는 데이터의 주소를 찾아 검색

* Clustered Index
  * 물리적으로 정렬이 되어 있는 상태로 데이터가 저장
  * 데이터를 인덱스로 지정한 컬럼에 맞춰서 정렬
    * 테이블 구조에 영향을 미치는 인덱스
    * 한 테이블에 하나만 생성 가능
  * 클러스터 키로 검색 시 처리 성능이 매우 빠름

# 쿼리

## SQL

* DML: 데이터를 조작
  |명령어|설명|
  |:---:|:---|
  |SELECT|DB의 데이터 조회 및 검색|
  |INSERT|데이터 삽입|
  |UPDATE|데이터 수정|
  |DELETE|데이터 삭제|
* DDL: 데이터(구조, 객체)를 정의
  |명령어|설명|
  |:---:|:---|
  |CREATE|DB의 테이블 생성|
  |DROP|테이블 삭제|
  |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
  |ALTER|테이블 수정|
  * DROP과 TRUNCATE의 차이
* DCL: 데이터 제어
  |명령어|설명|
  |:---:|:---|
  |GRANT|객체에 대한 권한 부여|
  |REVOKE|객체에 대한 권한 회수|
  |COMMIT|트랜잭션의 결과 반영|
  |ROLLBACK|트랜잭션 취소 및 원상 복구|

## 쿼리문 활용
- [쿼리문 활용](https://github.com/Hott-J/DataBase/blob/main/MySQL_Basic_Example.sql)

## Commit과 Rollback
* Rollback: 트랜잭션의 실행을 취소하였음을 알리는 연산자로 `트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산`

## SQL Injection
* 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
* view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 입력값 검증, Prepared Statement 사용(쿼리에 대한 컴파일을 먼저 수행하고, 입력값을 나중에 넣는 방식)

## 힌트(Hint)
* SQL을 튜닝하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것

# 운영체제

## 정의
- 하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하는 시스템 소프트웨어

# 해시
## 해시 테이블
- 검색하고자 하는 키값을 입력받아서 해시 함수를 돌려 반환받은 해시 코드를 배열의 인덱스로 환산을 해서 데이터를 접근하는 방식의 자료구조
- 고정된 배열방을 미리 선언

## 해시 함수
- 특정한 규칙을 이용하여 입력받은 키값으로 그 키값이 얼마나 큰지 상관없이 동일한 해시 코드를 만들어줌
- 사용자 정보는 너무 커서 전부 볼 수 없으므로 정보 조회할 경우 해시함수를 통해 해시코드를 만들어 동일한지 비교

## 해시 코드
- 정수
- 해시 코드를 배열의 갯수로 나머지 연산을 해서 배열에 나눠 담는 것
- 해시 코드 자체가 배열방의 인덱스로 사용되므로 검색자체를 할 필요가 없고 해시 코드로 바로 데이터의 위치에 직접적으로 접근할 수 있으므로 빠르다

## 문제점
- 같은 방에만 여러개가 있고 다른 방에 없으면 공간 낭비
    - 해시 알고리즘을 잘 짜야함
    - 충돌
    - 검색 시간이 O(n)이 걸릴 수 있다
        - 같은 방에 n명있으면 그 방 전체 사람을 검색해야하므로
    - 키 값을 얼마나 잘 골고루 분배하느냐가 중요
- 해시 코드는 문자열이고 무한대가 가능한데, 해시 코드는 정수이므로 무한대가 아니기에 어떤 키들은 중복된 해시 코드를 가질수 밖에 없다
- 다른 해시 코드이지만 배열방이 한정되어있으므로,인덱스가 같을(같은방)수도 있다
- 위 두가지 경우 모두 충돌이라 한다

## 해결법
- 체이닝
    - 연결 리스트를 사용
- 선형탐사
    - 체이닝을 하다보니, 리소스를 많이 먹는데 계속 이어버린다. 테이블을 안쓰고 계속 잇기만하면 비효율적.
        - 안쓴 방을 먼저 할당하자
        - 같은 인덱스가 들어왔을 경우, 같은 방에 배정하는게 아니라 비어있는 다음방에 밀어넣는다.
- 테이블 리사이징
    - 선형탐사를 통해 모든 방을 배정하게 되면 언젠가 꽉 차게 됨
    - 테이블의 할당된 공간을 다 쓰면 테이블의 크기를 늘려줌
    - 기존의 데이터를 해시 함수에 다시 넣어 재정렬을 함
    - 이후 다시 선형탐사로 오류에 대처함

## 예시
- 각 문자의 아스키 코드 값을 더함
    - sung : 445
    - jin : 321
    - hee : 306
    - min : 324
- 해시 함수
    - 해시 코드 % 크기
    - 445 % 3 = 1 (1번 인덱스에 저장)
    - 0
    - 0
    - 0
    - 충돌이 일어남 (0번 방에 3명이 같이 들어가게 됨)
- 배열방에 데이터를 바로 저장하는게 아니라 배열방안에 링크드리스트를 선언하고 데이터가 배열방에 할당받을 때마다 링크드 리스트에 데이터를 추가함
    - 해당방의 리스트를 돌면서 내가 찾고자 하는 값을 찾아오는 방식이다

