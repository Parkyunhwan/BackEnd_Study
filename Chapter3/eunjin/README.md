

## 데이터베이스

데이터:  단순한 관찰이나 측정 등의 수단을 통해 현실세계로부터 수집된 사일이나 값
정보 : 데이터중에서도 조직화되고 체계화 도니 데이터로써 의사 결정권자에게 의밀를 제공하는 것

- 정의 :  꼭 기억해야하는 데이터들의 집합

데이터베이스관리시스템 (DBMS) 데이터베이스를 관리해주는 시스템
데이터베이스의 생성, 접근방법, 처리절차, 보안 구조 등을 책임지며 대량의 데이터를 체계적으로 관리하고 검색, 활용할 수 있다

## 특징
	1. 데이터의 독립성 
		- 물리적 독립성 :  데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 
					관련된 응용프로그램을 수정할 필요 없다.
		- 논리적 독립성 : 데이터베이스는 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
	2. 데이터의 무결성
		여러 경로를 통해 잘못된 데이터가 발생한 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 무결성을 구현
	3. 데이터의 보안성
		허가된 사용자들만 데이터베이스나 데이터배이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근권한을 설정하여
		모든 데이터에 보안을 구현
	4. 데이터의 일관성
		연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다
	5. 데이터의 중복 최소화
		데이터베이스는 데이터를 통합해서 관리함으로써 데이터 중복 문제를 해결할 수 있다.

## 인덱스
	- DBMS에서 저장 성능 희앵하여 데이터 읽기 속도를 높이는 기능
	- 데이터가 정렬되어 들어간다
	- 양이 많은 테이블에서 일부 데이터만 불러 올 때, 풀 스캔 시 처리 성능 떨어짐
	- 종류
		- B+-Tree : 원래 값 이용해 인덱싱
		- Hash 인덱스 : 컬럼값으로 해시 값 계산하여 인덱싱
		- B> Hash ? SELECT 질의 시 부등호 연산 포함되어 = 연산에 특회된 Hash는 적합하지 않다

## 정규화
	
- 목적 : 데이터의 중복을 최소화 하고 테이블의 삽입,삭제, 갱신 과정에서 발생하는 이상현상을 방지 하기 위함

- 역정규화를 하는 이유?
	정규화를 진행할 수록 하나의 테이블을 여러 테이블로 나누게 되는데 
	만약 데이터 호출 시 여러테이블을 불러서 join을 해줘야한다면 이 비용도 만만치 않기 때문에 역 정규화


# OS
## Operation System
일반적으로 하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며, 시스템의 동작을 제어하는 시스템 소프트웨어로 정의한다.
→ 시스템의 자원과 동작을 관리하는 소프트웨어

OS 자체도 하나의 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라감.

But, 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 발생할 것.

따라서, 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때, 메모리에 올려서 사용하게 됨

메모리 상주하는 운영체제 부분 : 커널(Kernel) → 운영체제 코드 중 가장 핵심적인 부분!!


## 큰 틀
1. 프로세스 관리

프로세스, 스레드
스케줄링
동기화
IPC 통신
2. 저장장치 관리

메모리 관리
가상 메모리
파일 시스템
3. 네트워킹

TCP/IP
기타 프로토콜
4. 사용자 관리

계정 관리
접근권한 관리
5. 디바이스 드라이버

순차접근 장치
임의접근 장치
네트워크 장치









# Hash

## 개념
임의의 크기를 가진 데이터(Key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것
키에 대한 해시값을 사용하여 값을 저장하고 키-값 쌍의 갯수에 따라 동적으로 크기가 증가하는 associate array 이다 

키에 대한 해시값을 구하는 과정을 hashing(해싱)이라고 하며 이때 사용하는 함수(알고리즘)를 해시함수 라고 한다

해시값 자체를 index로 사용하기 때문에 평군 시간복잡도가 O(1) 로 매우 빠르다


## 해시함수

계산이 복잡하지 않고 키값에 대해 중복없이 해시값을 고르게 만들어 내는 함수가 좋은 함수 (충돌이 일어나지 않을수록 좋다)

대표적으로 나눗셈법(Division Method)와 곱셉법(Multiplication Method)이 있다
나눗셈법: 
원소를 해시테이블의 크기로 나누어 나머지값을 테이블의 주소로 사용하는 방법
테이블의 크기보다 원소의 갯수가 많으면 충돌이 일어난




## Collision
- 키에 대한 해시값이 같은 경우 = 사용하고자하는 해시 버킷이 이미 사용중인 경우

- 충돌 해결을 위해
* Chaining
- 충돌이 일어날 경우 데이터들을 포인터를 이용해 서로 링크드 리스트(체인)형태로 연결하는 것 
- key값을 포인터로 이어서 연결
- 최악의 경우 모든 데이터가 같은 해시값을 가져 O(n)의 복잡도를 가짐
- JDK 라이브러리에 구현된 HashMap 은 chaining 방식을 사용하며 해당 버킷의 길이에 따라 LinkedList에서 Tree로 변경될수 있다

*Open Addressing

- 모든 데이터를 테이블에 저장하는 방법
- 사용하려는 해시 버킷(테이블)이 이미 사용중인 경우 다른 버킷을 사용
- 포인터를 쓰지 않아 오버헤드를 방지할 수 있고 데이터가 적을 경우 연속된 공간에 인자를 저장하기 때문에 공간 효율이 높다
- 하지만 테이블의 크기가 커질수록 장점이 사라진다
