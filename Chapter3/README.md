# 3주차 질문 정리

### ✋🏻 데이터베이스가 무엇이며 왜 사용하나요?

여러 사용자들이 공유해서 사용할 목적으로 구조화하여 관리하는 데이터 집합입니다.
하나의 데이터베이스에 여러 응용프로그램이 접근할 수 있어서 데이터를 효율적으로 사용할 수 있습니다.
또한, 데이터가 여러 곳에 산재되어 있지 않고 하나에 모여있기 때문에 데이터의 무결성을 유지하기가 좋습니다.

- 데이터 중복의 최소화, 공용 데이터, 데이터의 일관성 유지(접근 시 유효성 검사),
데이터의 무결성 유지(정당한 사용자, 데이터, 연산 체크), 보안 보장, 표준화

### ✋🏻 파일시스템을 사용하지 않고 데이터베이스를 사용하는 이유?

파일 단위로 저장해서 사용할 때 `데이터 종속성` 문제와, `데이터 무결성` 문제가 발생하기 때문입니다.

- 데이터 종속성
    - 데이터 구성이나 접근 방법 변경 시 관련된 응용 프로그램도 변경해야한다
    - 다른 프로그램에서 필요한 데이터에 접근할 수 없다.
- 데이터 무결성
    - 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말함. 주로 데이터에 적용되는 연산에 제한을 둠
- 데이터 중복성으로 인한 일관성(데이터 간 불일치), 보안성, 경제성(저장 공간 낭비), 무결성(정확성 문제) 문제 발생 → 데이터에 대한 신뢰 하락

이러한 데이터 종속성, 중복성 문제 때문에 데이터베이스를 사용하게 되었습니다.

- DBMS

    → 데이터베이스와 응용프로그램 사이에서 데이터 사용에 대한 중재자 역할을 하는 데이터베이스 관리 시스템

### ✋🏻 클러스터드 인덱스와 넌 클러스터드 인덱스

- 저장

    클러스터드 인덱스는 데이터 삽입 시 정렬하여 디스크에 저장하고 넌 클러스터드 인덱스는 정렬하지 않고 저장한다.

- 크기
    - 클러스터드 인덱스
     데이터 정렬되어 있기 때문에 리프 레벨 인덱스 테이블 필요 x
    → 크기가 작다.
    - 넌 클러스터드 인덱스

        별도의 공간에 인덱스 테이블을 생성하여 데이터를 정렬한다.
        → 별도 저장 공간 사용

- 허용 선택 범위가 클러스터드 인덱스가 넌 클러스터드 인덱스보다 넓다
- 클러스터드 인덱스는 딱 1개만 생성 가능하며 넌 클러스터드 인덱스는 인덱스 테이블을 별도로 생성하여 데이터를 정렬하기에 충분히 많이 생성할 수 있다.

### ✋🏻  정규화 하는 이유

데이터의 중복을 최소한으로 줄이기 위해서 수행합니다. 그 이유는 코드의 변경에 변경이 생기면 중복된 부분을 모두 고쳐야한다는 문제점이 있는 것과 같이, 중복 데이터가 존재하면 여러가지 문제가 발생합니다.

- 삽입 이상
- 수정 이상
- 삭제 이상
- 갱신 이상

### ✋🏻   인덱스란?

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조 이다.

### ✋🏻   인덱스 자료구조

- B+ 트리

    → DB의 인덱스를 위해 자식노드가 2개 이상인 B-Tree를 개선시킨 자료구조

    - 리프노드만 인덱스/데이터를 함께 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스만을 갖는다.
    - 리프노드는 링크드리스트로 연결된다.

    인덱스 컬럼은 부등호를 이용한 검색 연산이 자주 발생하므로 이에 맞게 BTree를 최적화하였습니다.

### ✋🏻   데이터베이스 뷰

- 뷰는 사용자에게 접근이 허용된 자료만 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블이다.
- 뷰는 논리적 독립성을 제공하며 물리적으로 존재하지 않는다.
- 뷰를 사용하면 다양한 요구에 알맞는 데이터를 지원해주며 보안도 제공할 수 있다.

### ✋🏻   기본 키, 후보 키, 슈퍼 키?

`유일성` : 모든 레코드에서 해당 필드에 중복된 값이 나타나지 않는 속성

`최소성` : 최소한의 필드로 레코드를 유일하게 구별할 수 있는 속성

- 슈퍼 키
    - 유일성을 만족하는 테이블 필드들의 부분집합 (최소성은 만족 하지 않아도 됨)
- 후보 키
    - 기본 키가 될 수 있는 후보들. 유일성과 최소성을 만족하는 테이블 필드의 부분집합입니다.
- 특정 레코드를 구별하기 위해 후보 키 중 선택된 고유한 식별자를 말합니다.
유일성과 최소성의 속성을 가지며 NULL을 가질 수 없습니다.

### ✋🏻   해시 정의

`해시함수` 는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수.

이 해쉬함수에 의해 얻어지는 값을 `해시 값, 해시` 라고 합니다.

- 해시함수(hash function)란 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다.
이 때 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)라고 합니다.

해시테이블의 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리
- 색인에 해시값을 사용함으로써 검색과 삽입/삭제를 빠르게 수행할 수 있음
- 데이터 액세스 O(1)

단점 → 해시 충돌

적절한 load factor 설정 필요

### ✋🏻   해시 충돌 시 방안 2가지

- 체이닝 (한 인덱스에 여러개의 데이터가 리스트 형태로 들어갈 수 있음)
- 오픈어드레싱 (빈 공간을 찾아서 값이 삽입됨)

### ✋🏻   해시 맵, 해시 테이블

둘의 가장 큰 차이점은 동기화 보장유무와 키와 값에 null 가능 여부입니다.

동기화가 필요없다면 해시맵을, 동기화 보장이 필요하다면 해시테이블을 사용합니다.

- 멀티쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(Consistency)을 유지하기 위해 동기화가 필요.
- 해쉬테이블의 동기화는 속도를 굉장히 느리기 때문에,
동기화가 보장되는 HashMap이 등장 -> **ConcurrentHashMap**
- **동기화 보장 OK, 키와 값의 NULL 불가**
