# 9주차 정리

## static, non-static 차이

non-static 멤버

    공간적 특성: 멤버는 객체마다 별도로 존재한다.
    인스턴스 멤버 라고 부른다.
    시간적 특성: 객체 생성 시에 멤버가 생성된다.
    객체가 생길 때 멤버도 생성된다.
    객체 생성 후 멤버 사용이 가능하다.
    객체가 사라지면 멤버도 사라진다.
    공유의 특성: 공유되지 않는다.
    멤버는 객체 내에 각각의 공간을 유지한다.

static 멤버

    공간적 특성: 멤버는 클래스당 하나가 생성된다.
    멤버는 객체 내부가 아닌 별도의 공간에 생성된다.
    클래스 멤버 라고 부른다.
    시간적 특성: 클래스 로딩 시에 멤버가 생성된다.
    객체가 생기기 전에 이미 생성된다.
    객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)
    객체가 사라져도 멤버는 사라지지 않는다.
    멤버는 프로그램이 종료될 때 사라진다.
    공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유된다.
 
 static의 활용
 1. 전역 변수와 전역 함수를 만들 때 활용 :
    캡슐화의 원칙에 의해 클래스 바깥에 존재할 수 없고 무조건 클래스 안에 멤버로 존재해야 하므로 전역 변수나 전역 함수를 만들고 싶을 때 활용한다.
 2. 공유 멤버를 만들 때 활용 : static으로 선언된 필드나 메서드는 모두 이 클래스의 각 객체들의 공통 멤버가 되며 객체들 사이에서 공유된다.

static 메서드의 제약 조건
1. static 멤버만 접근 가능
2. this 키워드 사용 불가능

## final

* final 변수
    * 원시 타입 : 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됩니다. 
    * 객체 타입 : 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없습니다. 원시 타입과 동일하게 한번 쓰여진 변수는 재변경 불가합니다. 단, 객체 자체가 immutable하다는 의미는 아닙니다. 객체의 속성은 변경 가능합니다. 
    * 멤버 변수 : 클래스의 맴버 변수에 final로 선언하면 상수값이 되거나 write-once 필드로 한 번만 쓰이게 됩니다. final로 선언하면 초기화되는 시점은 생성자 메서드가 끝나기 전에 초기화가 됩니다. 하지만, static이냐 아니냐에 따라서도 초기화 시점이 달라집니다.
    * 메서드 인자 : 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수값을 변경할 수 없습니다. 
* final 메서드
    * 메서드를 final로 선언하면 상속받은 클래스에서 오버라이드가 불가능하게 됨. 구현한 코드의 변경을 원하지 않을 때 사용합니다. side-effect가 있으면 안 되는 자바 코어 라이브러리에서 final로 선언된 부분을 많이 찾을 수 있습니다.
* final 클래스
    * 클래스에 final을 선언하면 상속 자체가 안됩니다. 그냥 클래스 그대로 사용해야 합니다. Util 형식의 클래스나 여러 상수 값을 모아둔 Constants 클래스을 final로 선언합니다.
    * 유지보수를 위해서 사용합니다. 

## 동기, 비동기, block, non-block 차이

### 블럭/논블럭 

- 블럭/논블럭는 함수호출에서의 이야기이다.(기술적으로 명확히 구분된다.) 
- A 라는 함수를 호출했을때, A라는 함수를 호출 했을 때 기대하는 행위를 모두 끝마칠때까지 기다렸다가 리턴되면, 이것은 블로킹 되었다고 한다.
- A 라는 함수를 호출 했는데, A라는 함수를 호출 했을 때 기대하는 어떤 행위를  요청 하고 바로 리턴되면 이것은 논블럭킹 되었다고 한다.

### 동기/비동기

- 동기/비동기는 행위에 대한 이야기이다.(기술적으로 구분 안된다. 추상적으로 구분한다.) 
- A 라는 행위와 B 라는 별개의 행위가 있다고 하자. A 라는 행위와 B 라는 행위가 동시(or 순차적이지 않다면)에 실행되고 있으면 비동기라고 한다. 여기서 제약이 하나 있는데 A,B 행위 사이에는 인과관계가 있어야 한다. 즉 웹서버를 예로 들어서 멀티쓰레드로 각각 A와B가 다른 클라이언트와 작업 할 때 둘은 동시에 작업하고 있지만, 둘의 인과관계는 없지 않나? 이땐 비동기라고 볼 수 없다. 

- A라는 행위와  B라는 행위가 순차적으로 작동한다면 동기라고 한다. 
- 동기적 행동에는 하나가 더 있다. A라는 행위가 별개의 것이 아니라, B라는 행위를 관찰하는 행위라면 이것이 동시에 일어나더라도 동기이다. 기술적으로 말해서 A라는 쓰레드와 B라는 쓰레드가 따로 돌아 간다고 해도, 어떤 하나의 행위가 다른 행위에 밀착되어 있다면 두 행위가 다른 쓰레드에서 벌어지더라도 동기란 말이다. 관찰하는 행위라는 말자체가 정확한 기술적 구분이 되는게 아니기 때문에 추상적이라는 표현을 사용한 것이며, 이 글의 가장 불분명한 요소 중 하나이니 잘 기억해 두도록하자. 

## 락 기법

### 세마포어
프로세스간의 시그널(신호, Signal)을 주고받기 위해 사용되는 정수 값, 리소스의 상태를 나타내는 카운터로 세마포어는 다음 세가지 원자적인 연산만을 지원합니다.

- initialize, decrement, increment

- initialize : 세마포어 초기화. (음이 아닌 정수값으로 초기화)

- decrement : 프로세스를 블록시킬 수 있습니다.

- increment : 블록되었던 프로세스를 깨울 수 있습니다. 이 세마포어를 카운팅 세마포어 또는 범용 세마포어라고 합니다.

세마포어의 값에 따라 운영체제는 프로세스가 즉시 자원을 사용할 지, 자원이 다른 프로세스에 의해 사용 중인걸 알게 될 경우엔 일정 시간을 기다려야 합니다.

프로세스가 자원을 사용하는 동안에는 세마포어 값을 변경함으로서 다른 프로세스들이 기다리게 해야합니다.

- 프로세스간 메시지를 전송하거나 공유메모리를 통해 특정 데이터를 공유하게 될 경우 공유 자원에 여러 프로세스가 접근하면서 문제가 발생하게 됩니다.

 + 하나의 프로세스만 자원에 접근 가능하도록 설정할 때 세마포어를 사용합니다.

### 모니터
Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다. 예를 들어 자바에서 모든 객체는 Object 클래스를 상속 받는다. 이 Object 클래스에는 wait(), notifyAll(), notify() 메소드를 가지고 있는데 이게 바로 Condition Variables 역할이라고 보면 된다. 고로 모든 자바 객체는 Monitor를 가지고 있다. 자바에서는 Mutual Exclusion 해결을 위한 구현체로 Synchronized 키워드가 있다. 예를 들어 Synchronized가 메소드에 선언되어있고, 쓰레드A가 이미 Lock을 획득해서 Critical Section(메소드)을 수행중이라고 가정하자. 쓰레드B가 동일한 메소드를 수행하기 위해 해당 Object의Lock을 획득해야 할 것이다. 이 Lock이 반환될 때까지 대기를 해야하는데 그 때 사용되는게 바로 Monitor다. 쓰레드A가 Lock을 반환하면 쓰레드B는 기다렸다가 Lock을 획득하게 된다. 그리고 Critical Section인 메소드를 수행할 수 있게 된다. 물론 Synchronized 키워드를 사용했을 때 자동적으로 수행되는 내부 동작이고, 별도로 명시적인 Monitor를 구현할 수도 있다.아무튼 Monitor는 이렇게 Mutex(Lock)과 Condition Variables을 이용해서 Mutual Exclustion을 해결하고 있다. 그 외 Monitor의 다른 정의로는 공유자원에 안전하게 접근하기 위해 Mutual Exclusion가 랩핑된 Thread-Safe한 클래스, 객체, 모듈들을 의미하기도 한다.


### 뮤텍스
MUTual EXclusion으로 상호배제라고도 합니다.

0또는 1의 값을 가지는 이진 세마포어와 유사합니다. Critical Section (임계구역)을 가진 스레드들의 실행 시간을 서로 겹치지 않게 단독으로 실행하게 하는 기술입니다.

- 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 Locking과 Unlocking을 사용합니다.

- 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없습니다.

### 세마포어와 뮤텍스의 차이

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없습니다.

- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그에 대한 책임을 집니다.

- 뮤텍스의 경우 뮤텍스를 소유하고있는 스레드가 이 뮤텍스를 해제할 수 있습니다. 하지만, 세마포어는 소유하지 않고 있는 스레드가 세마포어를 해제할 수 있습니다.

- 세마포어는 시스템 범위에 걸쳐있고 파일 시스템 상의 파일 형태로 존재합니다. 하지만, 뮤텍스는 프로세스 범위를 가지고 프로그램이 종료될 때 자동으로 지워집니다.

- 세마포어는 동기화 대상이 여러개 일 때, 뮤텍스는 동기화 대상이 오로지 하나 일 때 사용됩니다.

### 세마포어와 모니터의 차이

세마포어에 비해서 모니터 쪽이 공유자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해서 간단하다. 세마포어는 직접 키해제와 공유자원 접근 처리를 해주어야한다.​

​ 자바는 모니터 방식!!!!

