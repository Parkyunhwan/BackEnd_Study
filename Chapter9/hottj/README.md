# 자바 final
* final 변수
    * 원시 타입 : 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됩니다. 
    * 객체 타입 : 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없습니다. 원시 타입과 동일하게 한번 쓰여진 변수는 재변경 불가합니다. 단, 객체 자체가 immutable하다는 의미는 아닙니다. 객체의 속성은 변경 가능합니다. 
    * 멤버 변수 : 클래스의 맴버 변수에 final로 선언하면 상수값이 되거나 write-once 필드로 한 번만 쓰이게 됩니다. final로 선언하면 초기화되는 시점은 생성자 메서드가 끝나기 전에 초기화가 됩니다. 하지만, static이냐 아니냐에 따라서도 초기화 시점이 달라집니다.
    * 메서드 인자 : 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수값을 변경할 수 없습니다. 
* final 메서드
    * 메서드를 final로 선언하면 상속받은 클래스에서 오버라이드가 불가능하게 됨. 구현한 코드의 변경을 원하지 않을 때 사용합니다. side-effect가 있으면 안 되는 자바 코어 라이브러리에서 final로 선언된 부분을 많이 찾을 수 있습니다.
* final 클래스
    * 클래스에 final을 선언하면 상속 자체가 안됩니다. 그냥 클래스 그대로 사용해야 합니다. Util 형식의 클래스나 여러 상수 값을 모아둔 Constants 클래스을 final로 선언합니다.
    * 유지보수를 위해서 사용합니다. 
[참고](https://advenoh.tistory.com/13)

# 자바 static/non-static
* static 멤버
    * 공간적 특성
        * 멤버는 클래스당 하나가 생성된다.
        * 멤버는 객체 내부가 아닌 별도의 공간에 생성된다.
        * 클래스 멤버 라고 부른다.
    * 시간적 특성: 클래스 로딩 시에 멤버가 생성된다.
        * 객체가 생기기 전에 이미 생성된다.
        * 객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)
        * 객체가 사라져도 멤버는 사라지지 않는다.
        * 멤버는 프로그램이 종료될 때 사라진다.
    * 공유의 특성
        * 동일한 클래스의 모든 객체들에 의해 공유된다.
    * static 메서드는 오직 static 멤버만 접근할 수 있다.
        * 그러나 인스턴스 메서드는 static 멤버들을 모두 사용할 수 있다.
    * static 메서드에서는 this 키워드를 사용할 수 없다.
        * this는 호출 당시 실행 중인 객체를 가리키는 레퍼런스이다.
    * static 멤버에 접근할때 static 초기화 블록이 호출된다.
* non-static 멤버
    * 공간적 특성
        *  멤버는 객체마다 별도로 존재한다.
        * 인스턴스 멤버 라고 부른다.
    * 시간적 특성
        * 객체 생성 시에 멤버가 생성된다.
        * 객체가 생길 때 멤버도 생성된다.
        * 객체 생성 후 멤버 사용이 가능하다.
        * 객체가 사라지면 멤버도 사라진다.
    * 공유의 특성
        * 공유되지 않는다.
        * 멤버는 객체 내에 각각의 공간을 유지한다.
[참고](https://gmlwjd9405.github.io/2018/08/04/java-static.html)
[초기화블록](https://freeprog.tistory.com/198)

# 동기식/비동기식, 블락/논블락
* 동기식과 비동기식의 차이
  * 동기식은 요청에 대한 응답을 기다린 후 `응답이 오면 실행`하는 방식이고 비동기식은 요청에 대한 `응답을 기다리지 않고 실행`하는 방식
  * 동기식은 구성이 단순하나 멀티태스킹이 불가능하고 비동기식은 멀티태스킹이 가능하나 요청량이 많아질 경우 부하 컨트롤과 데이터의 일관성 유지 등 추가적인 처리가 필요
  * 동기는 호출한 함수가 작업 완료를 신경쓰고, 비동기는 호출된 함수가 작업 완료를 신경씀

* 블락킹과 논블락킹의 차이
  * 블락킹은 주로 I/0 처리 함수가 끝날 때까지 기다리고 처리가 끝나면 결과를 리턴하는 방식이고 논블락킹은 I/0 처리 함수가 끝나지 않더라도 기다리지 않고 다른 작업을 처리하는 방식
  * 블락킹은 요청한 작업을 마칠 때까지 계속 기다리고, 논블락킹은 요청한 작업을 즉시 마칠 수 없다면 즉시 리턴함

* 블락킹/논블락킹과 동기/비동기의 차이
  * 관심사가 다르다
  * 블락킹/논블락킹
    * 호출되는 함수가 `바로 return하느냐 마느냐가` 관심사이다.
  * 동기/비동기
    * 호출되는 함수의 `작업 완료 여부를 누가 신경쓰느냐가` 관심사이다.
    * 비동기는 `콜백`으로 호출된 함수가 완료 여부를 신경쓰고 호출한 함수는 그냥 자기일을 하다가 콜백을 받으면 됨
  * [참고](https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking)

# 락 기법
[참고](https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a)
[뮤텍스,세마포어,모니터](https://about-myeong.tistory.com/34)
