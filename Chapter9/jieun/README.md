# final, non-static멤버와 static 멤버 차이

### java의 non-static 멤버와 static 멤버의 차이
### non-static 멤버
공간적 특성: 멤버는 객체마다 별도로 존재한다.

인스턴스 멤버 라고 부른다.

시간적 특성: 객체 생성 시에 멤버가 생성된다.

객체가 생길 때 멤버도 생성된다.

객체 생성 후 멤버 사용이 가능하다.

객체가 사라지면 멤버도 사라진다.

공유의 특성: 공유되지 않는다.

멤버는 객체 내에 각각의 공간을 유지한다.

### static 멤버
공간적 특성: 멤버는 클래스당 하나가 생성된다.

멤버는 객체 내부가 아닌 별도의 공간에 생성된다.

클래스 멤버 라고 부른다.

시간적 특성: 클래스 로딩 시에 멤버가 생성된다.

객체가 생기기 전에 이미 생성된다.

객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)

객체가 사라져도 멤버는 사라지지 않는다.

공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유된다.


### final 키워드

개념: 변수나 메서드 또는 클래스가 ‘변경 불가능’하도록 만든다.

원시(Primitive) 변수에 적용 시
해당 변수의 값은 변경이 불가능하다.

참조(Reference) 변수에 적용 시
참조 변수가 힙(heap) 내의 다른 객체를 가리키도록 변경할 수 없다.

메서드에 적용 시
해당 메서드를 오버라이드할 수 없다.

클래스에 적용 시
해당 클래스의 하위 클래스를 정의할 수 없다.

# 비동기 동기

- 동기와 비동기의 차이점
동기는 request 후 response 기다림.
비동기는 기다리지 않음.

- 비동기 처리의 대표적인 예 : 
ajax, fetch, axios 등으로 json 통신하기.

1. 동기(Synchronous)

    - 요청과 결과가 동시에 일어난다

    - 함수의 결과를 호출한 쪽에서 처리한다.

    - 결과가 나올 때까지 대기해야 한다.

    - 설계가 매우 간단하다.

 

2. 비동기(Asynchronous)

    - 요청과 그 결과가 동시에 일어나지 않는다.

    - 함수의 결과를 호출한 쪽에서 처리하지 않는다.

    - 결과가 나올 때까지 다른 작업을 수행할 수 있어 자원을 효율적으로 사용할 수 있다.

    - 설계가 동기보다 복잡하다.


# block, non-block

1. 블로킹 (Blocking)
    - 호출된 함수가 자신의 작업을 모두 끝낼때까지 제어권을 가지고 있어 호출한 함수가 대기하도록 만든다.
    - 클라이언트가 I/O 작업을 진행하면 해당 프로세스가 진행하는 작업이 중지된다.
    - 다른 클라이언트에 영향을 미치지 않게 하기 위해 클라이언트 별로 쓰레드를 만들어야 한다.
    - 쓰레드가 많이질수록 CPU의 컨텍스트 스위칭 횟수가 증가한다.
    - 쓰레드가 요청한 동작이 수행 가능해질 때 까지 대기한다.
 
2. 논블로킹 (Non-Blocking)
    - 호출된 함수가 바로 return 해서 호출한 함수에게 제어권을 주어 다른 일을 할 수 있게 한다.
    - Blocking 방식의 비효율성을 극복하고자 만든 것이다.
    - 클라이언트가 I/O 작업을 진행해도 유저 프로세스의 작업을 중단시키지 않는다.
    - 요청된 동작이 현재 수행 불가능하다는 사실을 쓰레드에게 알린다.

# 락 기법

왜 락(lock)이 필요할까요?
먼저 들어가기에 앞서서 공유 자원이란 무엇인지 알아보도록 하겠습니다.

지역 변수는 공유 자원일 수 없습니다. 쓰레드 사이에서 공유될 수 없기 때문입니다.
전역 변수는 쓰레드 사이 공유되므로 공유 자원입니다.
동적인 객체는 쓰레드 사이 공유되므로 공유 자원입니다.
프로세스들도 메모리를 공유할 수 있습니다.
공유 자원의 여러 쓰레드가 사용 하게되면 동기화 문제가 발생하게 됩니다. 왜냐하면 동시성은 비결정적인 결과(non-deterministic)를 이끌어 내기 때문입니다. 이는 앞에서 이야기 하였듯이 2개 도는 그 이상의 동시에 동작하는 쓰레드들이 공유 자원에 접근을 하면 경쟁 상태(race condition)에 도달하기 때문입니다.

따라서 우리는 동기화(synchronization)를 하여 공유 자원에 대해서 관리를 할 필요가 있습니다.

우리는 일전에 저런 공유 자원에 접근하는 구간을 보고 임계 구역(Critical Section)이라고 명명한 바가 있습니다. 이런 임계 구역은 상호 배제(mutual exclusion)해야 한다는 것을 우리는 익히 압니다. 이런 상호배제를 구현하기 위해서는 아래를 만족을 해야합니다.

임계 구역에서의 실행은 원자적(Atomic)이여야 합니다. (전체 거나 아무것도 없거나)
오직 하나의 쓰레드를 임계 구역에서는 하나만 실행할 수 있습니다.
모든 다른 쓰레드는 기다리는 상태에 들어가게 됩니다.
쓰레드가 임계 구역을 빠져나오면 다른 것이 들어가게 됩니다.

lock()
락을 acquired를 시도해봅니다.
만약 락을 어떠한 쓰레드도 가지고 있지 않는다면, 쓰레드는 락을 acquired할 수 있습니다.
이 acquired가 수행된 이후에 임계 구역에 들어가게 되고 이 쓰레드가 락의 소유자(owner)가 됩니다.
이와 다르게, 이미 락이 다른 쓰레드로 acquired가 된 상태라면 임계 구역에 들어가는 것을 막습니다.
unlock()
락의 소유자가 unlock()을 부르는 경우, 락은 다시 availabe(free)상태가 됩니다.
lock()을 기다리는 다른 쓰레드를 깨우도록 합니다.
