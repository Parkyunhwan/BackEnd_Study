# IPC

### IPC란?
프로세스 사이의 데이터통신은 IPC를 통해서 합니다. IPC는 영문 약자 그대로 "프로세스 간 통신"이라는 뜻이구요, 커널은 프로세스 통신을 위해 다양한 IPC매커니즘을 제공합니다.

 

프로세스는 IPC를 통하여 다른 프로세스에게 데이터를 송신하거나, 다른 프로세스로부터 데이터를 수신할 수 있습니다.

### IPC 종류

 1) PIPE

    (1) 정의

      - 익명의 PIPE를 통해서 동일한 PPID를 가진 프로세스들 간에 단방향 통신을 지원

    (2) 구조

      -  FIFO 구조

      - 생성된 PIPE에 대하여 Write 또는 Read만 가능

    (3) 사용 시기

      - 부모 자식 프로세스간 통신 할때 사용

    (4) 유의사항

      - 쌍방 통신을 위해서는 Write용 PIPE하나 Read PIPE하나 씩 만들어야 한다.

      - read()와 write()가 기본적으로 block 모드로 작동하기 때문으로 프로세스가 read대기중이라면

        read가 끝나기 전에는 write를 할수가 없게 된다.


  1) Named PIPE

    (1) 정의

      - 이름을 가진 PIPE를 통해서 프로세스들 간에 단방향 통신을 지원

      - 서로 다른 프로세스들이 PIPE의 이름만 알면 통신이 가능하다.

    (2) 구조

      - FIFO 구조

      - 생성된 PIPE에 대하여 Write 또는 Read만 가능

    (3) 사용 시기

      - 연관이 전혀 없는 프로세스간에 통신을 할때

    (4) 유의사항

      - 쌍방 통신을 위해서는 Write용 PIPE하나 Read PIPE하나 씩 만들어야 한다.

      - read()와 write()가 기본적으로 block 모드로 작동하기 때문으로 프로세스가 read대기중이라면

        read가 끝나기 전에는 write를 할수가 없게 된다.




  2) Message Queue

    (1) 졍의

      - 메모리를 사용한 PIPE이다.

      - 구조체 기반으로 통신을 한다.

    (2) 구조

      - FIFO 구조

      - msgtype에 따라 다른 구조체를 가져올수 있다.

    (3) 사용시기

      - 프로세스간 다양한 통신을 할 때 사용 할수 있다.

    (4) 유의사항

      - 커널에서 제공하는 Message queue 이기 때문에 EnQueue 하는데 제한이 존재 한다.



  3) Shared Memory

    (1) 졍의

      - 시스템 상의 공유 메모리를 통해 통신한다.

    (2) 구조

      - 일정한 크기의 메모리를 프로세스간에 공유하는 구조

      - 공유 메모리는 커널에서 관리 된다,

      * 자세한 정보 : [메모리] share memory 사용법

    (3) 사용시기

      - 프로세스간 Read, Write를 모두 필요로 할때

    (4) 유의사항 

      - 프로세스간의 상요할려면 메모리 크키가 동일 해야 한다.

	  

  4) Memory Map

    (1) 정의

      - 파일을 프로세스의 메모리에 일정 부분 맵핑 키셔 사용한다.

    (2) 구조 (위키 설명 : 메모리 맵 파일 )

      - 위키보다 더 잘 설명할 자신이 없기에 위키 내용으로 대체합니다.

메모리 맵 파일을 사용하면 디스크에 있는 파일의 블록들과 프로세스의 페이지가 연결된다. 이 상태에서는 가상 메모리에 사상만 되어 있을 뿐이며, 실제 메모리에 파일을 불러오는 시기는 해당 주소에 읽거나 쓰기 작업을 시도할 때 이루어진다. 이 작업은 운영 체제에서 가상 메모리를 다루는 데 사용하는 페이징 기법과 같이 페이지 부재를 일으키는 방식을 이용한다. 일반적으로 파일에서 불러오는 자료는 페이지 크기와 같은 4KiB이지만, 몇몇 운영 체제에서는 하드디스크의 낮은 임의 접근 시간을 고려해 4KiB보다 많은 자료를 페이지로 올릴 수도 있다.

이 때문에 메모리 맵 파일로 작업 중인 데이터가 실제 파일로 바로 반영되지는 않으며, 페이지 교체 알고리즘에 따라 해당 페이지가 메모리에서 내려갈 경우, 또는 메모리 맵 파일을 닫는 과정에서 반영된다. 이것은 메모리 맵 파일과 파일 입출력 API를 동시에 사용할 때 문제가 되는데, 메모리 맵 파일을 통해 변경된 자료는 즉시 반영되지 않으므로 그 지점에 해당하는 자료를 파일 입출력 API를 사용하여 읽어오려 할 때 동기화 문제가 발생하게 된다. 따라서 메모리 맵 파일을 사용할 때에는 읽기 전용으로만 사용하는 목적이 아닌 이상 파일 입출력 API를 사용하지 않는 것이 좋다.

오른쪽 위의 예제 그림은 메모리 맵 파일을 사용할 때 프로세스의 가상 주소와 물리 주소, 그리고 파일들의 관계를 알 수 있다. 각 블록은 페이지 단위로 나타낸 것이다. 예제에서는 프로세스 2개와 파일 2개가 나오며, 이중 b2는 메모리 맵 파일의 공유를, b3는 사상이 되었으나 아직 메모리에 적재되지 않은 것을 나타낸다.

    (3) 사용시기

      - 파일로 대용량 데이터를 공유 할 때 사용한다.

      - FILE IO가 느릴때 사용하면좋다.

      - 대부분 운영 체제에서는 프로세스를 실행할 때 실행 파일의 각 세그먼트를 메모리에 사상하기 위해 

        메모리 맵 파일을 이용한다.

    (4) 유의 사항

      - write시기는  프로세스의 페이지가 메모리에에서 내려갈 때만 Write된다. 

        이렇게 때문에 메모리와 file Sync가 안맞을수 도있다.

      - IA-32 기반 시스템에서 하나의 프로세스에서 PAE 기술을 사용하지 않고 사용 가능한 최대 크기는

        4GB로 제한된다

      - 메모리 맵 파일은 파일의 크기를 바꿀 수는 없으며 메모리 맵 파일을 사용하기 이전, 또는 이후에만 

        파일의 크기를 바꿀 수 있다.



  1) Socket

    (1) 정의

      - 네트워크 소켓통신을 시용한 데이터 공유

    (2) 구조

      - 네트워크 소켓을 이용하여 Client - Server 구조로 데이터 통신

    (3) 사용시기

      - 원격에서 프로세스간 데이터를 공유 할 때 사용

    (4) 유의 사항

      - 네크워크 프로그래밍이 가능해야 한다.

      - 데이터 세그먼트 처리를 잘해야한다.


# Call by Value, Call by Reference, Pimitive, Reference Type 차이

### Call by value(값에 의한 호출), Call by reference(레퍼런스에 의한 호출) 에 대해 설명하세요.

Call by value 는 값을 복사해서 새로운 함수로 넘기는 호출 방식이다. 원본값 변경하지 않는다.

Call by reference 는 주솟값을 인자로 전달하는 호출 방식이다. 원본값 변경이 가능하다. 

자바언어는 Call by value 이다.

### 각각의 장단점

call by value : 복사하며 처리하기 때문에 매개변수로 전달된 값이 보존이 되고 안전 / 메모리 사용량 늘어남
call by reference : 직접 참조를 하기 때문에 실행 속도가 빠르다 / 원래의 값의 영향을 받는다.

### primitive type, reference type에 대해 설명해주세요

primitive type : 변수에 값 자체를 저장 

- type 마다 size가 fix
- 기본값이 있으므로 null이 존재하지 않음
- generic을 이용할 때 필요한 wraper class가 존재(Integer, Long..)
- 컴파일 시, 크기를 초과하면 에러가 발생
- primitive type의 변수는 thread의 stack memory에 저장

reference type : 메모리상에 객체가 있는 위치를 저장

- 기본형을 제외한 모든 타입은 Reference Type 이며 java.lang.Object 를 상속
- Class, Interface, Array, Enum Type
- 기본값은 아무런 참조 정보가 없으므로 null을 리턴
- new, Reflection, sun.misc.Unsafe 등으로 객체를 생성
- HotSpot 기준 아무것도 없는 Class도 8Byte를 차지
- boolean type 1개가 존재하는 Class는 16Byte를 차지합니다. (기본 1Byte + - 1Byte (boolean 1bit 나머지 padding값)
- 생성된 객체는 Heap Memory에 저장
(Java Object Size Calculations in 64-bit)

### string은 reference type이다.


# Java Collection 객체

### Java Collection Framework의 기본 인터페이스는 무엇입니까?

- Collection 인터페이스 

- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.

   - ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.

    - LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.

    - Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리

Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우

  Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.

    - HashSet

    - TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.

     - HashMap

     - TreeMap

     - Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.

     - Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.


### arraylist와 linkedlist의 차이점은?

Array는 미리 데이터의 색인(Index)를 지정하여 저장하는 특성이 있어, 랜덤엑세스 성능이 뛰어나다. 하지만 데이터를 새로 저장하거나 삭제할 때는 색인을 모두 수정해야하므로 불리하다. 반대로 LinkedList는 데이터를 검색할 때는 head에서부터 차례로 노드를 찾아다니는 비효율이 있지만, 데이터를 새로 저장하거나 삭제할 때는 다음 노드를 가리키는 포인터만 변경해야하므로 효율적이다.

# JDBC, ORM, SQLMapper
### JDBC란?
자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.
JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.

각 DB와의 연결을 드라이버를 통해 하고 있으며
이 때문에 어떤 한 DB에 종속적으로 적용되지 않는다.
DB를 바꿔야 할 때, 드라이버만 바꿔준다면, 코드의 수정이 없어도 잘 쓸 수 있다.

자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.

### ORM이란?
DB의 record와 객체를 매핑(ORM)
객체(Object)와 관계형 데이터베이스(RDBMS)을 매핑하여 데이터베이스 테이블을 객체지향적으로 사용하기 위한 기술이다.
ORM을 사용한다면, SQL문 작성 없이 매핑하는 설정만으로 DB 테이블내의 데이터를 객체로 전달 받을 수 있다.
ORM을 사용하기 위해서는 DB 설계가 잘되어있어야 한다.
ORM 기술 표준이다. 대표적으로 Hibernate, OpenJPA, EclipseLink, TopLink Essentials와 같은 구현체(ORM 프레임워크)가 있다.

객체와 관계형 데이터베이스의 데이터를 자동으로 연결해주는 개념입니다. 즉, 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해줍니다.

#### 장점

SQL Query문을 길게 쓸 필요없이 ORM 메소드로 데이터들을 제어할 수 있어 프로그래머가 로직에 더 집중할수 있게 도와줍니다.
각종 역할에 대해 객체나 함수로 만들어서 하기 때문에, 코드 가독성 및 유지보수의 편리성이 증가합니다.
DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요됩니다.
SQL Injection 공격을 막아주는 기능이 있어 버그나 해킹가능한 요소들을 줄여줍니다.

#### 단점

완벽한 ORM으로만 서비스를 구현하기 어렵습니다.
사용하기엔 편하지만 설계를 신중하게 해야합니다.
잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있습니다.
프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵습니다.
이미 프로시저가 많은 시스템에서는 다시 객체로 바꿔야하며, 그 변경하는 과정에서 생산성이 저하되거나, 리스크가 많이 발생할 수 있습니다.
* 프로시저 : 프로그램의 기능에 따라 여러 개의 단위로 분해한 것입니다.

### SQLMapper란?

객체(Object)와 SQL 문을 매핑하여 데이터를 객체화하는 기술을 뜻한다.
객체와 관계를 매핑하기보다는 SQL문의 질의 결과와 객체를 매핑시켜주기 때문에 ORM과는 다른 기술이라고 할 수 있다.
대표적인 프레임워크로는 iBatis, MyBatis, Oracle SQLJ 가 있다.

### SQLMapper와 ORM의 차이. 장단점은 무엇인가

ORM(Object Relational Mapping)은 RDB를 객체지향적으로 사용하기 위한 기술입니다. 프로그램내의 객체하고 RDB 테이블에 매핑되어서 DB를 객체처럼 사용 가능합니다. SQL을 사용하지 않기 때문에 개발이 편해지는 장점이 있습니다. 하지만 ORM을 사용하려면 DB 설계가 잘 되어 있어야 한다는 문제가 있습니다.

SQLMapper는 객체와 SQL문을 매핑해서 데이터를 객체화 하는 기술입니다.

SQL의 질의 결과와 객체를 매핑하기 때문에 ORM과는 차이가 있습니다.

