# IPC
: Process는 완전히 독립된 실행객체 -> 다른 프로세스의 영향을 받지 않는다 <br>
  별도의 설비가 없이는 서로간의 통신이 어렵다 <br>
  커널영역에서 IPC라는 내부 프로세스간 통신을 제공 <br>
  프로세스는 커널이 제공하는 IPC설비를 이용해서 프로세스간 통신 <br>
  
  

#### IPC 종류

1. ##### 익명 PIPE

   > 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다.
   >
   > **한쪽 방향으로만 통신이 가능한 반이중 통신**이라고도 부른다.
   >
   > 따라서 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 한다.
   >
   > 매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다. 단점으로는 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 된다.

2. ##### Named PIPE(FIFO)

   > 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신처럼)
   >
   > Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다.
   >
   > 즉, 익명 파이프의 확장된 상태로 **부모 프로세스와 무관한 다른 프로세스도 통신이 가능한 것** (통신을 위해 이름있는 파일을 사용)
   >
   > 하지만, Named 파이프 역시 읽기/쓰기 동시에 불가능함. 따라서 전이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능

3. ##### Message Queue

   > 입출력 방식은 Named 파이프와 동일함
   >
   > 다른점은 메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.
   >
   > 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.

4. ##### 공유 메모리

   > 파이프, 메시지 큐가 통신을 이용한 설비라면, **공유 메모리는 데이터 자체를 공유하도록 지원하는 설비**다.
   >
   > 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.
   >
   > 공유 메모리는 **프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용**해준다.
   >
   > 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.
   >
   > - **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**

5. ##### 메모리 맵

   > 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 **열린 파일을 메모리에 맵핑시켜서 공유**하는 방식이다. (즉 공유 매개체가 파일+메모리)
   >
   > 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.

6. ##### 소켓

   > 네트워크 소켓 통신을 통해 데이터를 공유한다.
   >
   > 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
   >
   > 서버(bind, listen, accept), 클라이언트(connect)
   > 

# 2. Call by value, Call by Reference 와 Primitive, Reference Type 차이

### Call by value(값에 의한 호출)
- 장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.
- 단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.

### Call by reference(참조에 의한 호출)
- 장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
- 단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)


### Primitive type - 변수에 값 자체를 저장 

정수형 byte, short, int, long

실수형 float, double

문자형 char

논리형 boolean
 

### Reference type - 메모리상에 객체가 있는 위치를 저장

종류 - Class, Interface, Array 등

<hr>

# Collection api

1. List 인터페이스

2. Set 인터페이스

3. Map 인터페이스

[ SET ]

HashSet     동기화 X    가장 빠른 집합, HashMap보다 느림

TreeSet      동기화 X    HashSet 보다 느림, 키가 정렬됨

[ MAP ]

HashMap    동기화 X    가장 빠름, null 값 허용

Hashtable   동기화 O    HashMap보다 느림, 동기화, null 값 허용안함

TreeMap     동기화 X    Hashtable과 HashMap보다 느림, 키가 정렬됨

[ LIST ]

ArrayList     동기화 X    가장빠름, null 허용

LinkedList   동기화 X    느림

Vector         동기화 O    ArrayList 보다 느림

Stack           동기화 O    Vector와 동일한 속도, LIFO 가능



# JDBC, ORM, SQLmapper, MyBatis 등의 차이


1. ### JDBC
- JDBC는 자바 프로그램이 관계형 데이터 베이스에 Access하도록 자바 API Set을 제공한다.
- Java APIS 자바프로그램이 SQL 실행할 수 있게 한다. 그리고 SQL과 상호작용한다.
- JDBC는 database independent에 쓰기 위한 유연한 구조를 제공한다.
  JDBC는 어떤 수정(변경)없이 다른 DBMS 상호 작용하며 다른 플랫폼 위에서도 실행될 수 있다.

장점

 - 가볍도 단순한 SQL 프로세싱
 - 많은 양의 데이터도 좋은 성능을 낸다.
 - 작은 어플리케이션에 완전 짱
 - 쉬운 문법과 배우기 쉽다.


단점

 - 대형 프로젝트에서 사용하기가 복잡함
 - 엄청난 프로그래밍 오버헤드
 - 캡슐화 안됌
 - MVC 콘셉을 구현하기 어려움
 - 독특한 DBMS 쿼리


2. ### ORM

프로그래밍 기술인데 관계형 데이터 베이스와 OOP 랭기지(자바,C#같은)를 컨버팅하는 기술이다.

-  ORM 시스템은 아래와 같은 장점을 가진다.
    1. 비지지스 코드가 DB 테이블에 접근하게 해준다.

    2. JDBC를 기본으로 한다.

    3. 데이터베이스를 상속(구현할)필요가 없다.

    4. 엔트리가 비즈니스 컨셉에 기초가한다, 데이터베이스 구조보다.

    5. 어플리케이션 개발이 빠르다.



3. ### SQLmapper
SQL <—매핑—> Object 필드
SQL Mapper는 SQL 문장으로 직접 데이터베이스 데이터를 다룬다.
즉, SQL Mapper는 SQL을 명시해줘야 한다.



4. ##### MyBatis

자바 오브젝트와 SQL사이의 자동 매핑 기능을 지원하는 ORM(Object relational Mapping)프레임워크이다.

SQL을 별도의 파일로 분리해서 관리하게 해준다.

Hibernate나 JAP(Java Persistence Api)처럼 새로운 DB프로그래밍 패러다임을 익혀야하는 부담 없이 SQL을 그대로 이용하면서 

JDBC코드 작성의 불편함도 제거해주고 도메인 객체나 VO객체를 중심으로 개발이 가능하다는 장점이 있다.

