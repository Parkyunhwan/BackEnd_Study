
## 얕은복사 vs 깊은 복사

1. 얕은 복사(Shallow Copy)
	- 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
	- 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
	- 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
2. 깊은 복사(Deep Copy)
  - 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
  - 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.

## CPU 스케줄링

#### 이루어지는 시기

- 프로세스가 입/출력을 요구할 때
- 프로세스가 종료를 요구할 때
- 높은 우선순위의 프로세스가 나타났을 때
- 주어진 CPU 실행 시간을 초과했을 때 



#### 선점스케줄링

 - CPU가 어떤 프로세스에 의해 점유 중일 때, 우선 순위가 높은 프로세스가 CPU를 차지할 수 있음
 - 우선 순위가 높은 프로세스를 빠르게 처리해야할 경우 유용.
 - 선점이 일어날 경우, 오버헤드가 발생하며 처리시간을 예측하기 힘듦.

 * 종류
 
        1-1. SRT(Shortest Remaining Time) 스케줄링: 짧은 시간 순서대로 프로세스를 수행한다. 
        남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점됨. 아래에 소개할 SJF의 선점 버전이라고 할 수 있다.

        1-2. 라운드로빈(Round-Robin)스케줄링: 각 프로세스는 같은 크기의 CPU 시간을 할당 받고 선입선출에 의해 행된다. 
        할당시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커진다.

        1-3. 다단계 큐(Multi-level Queue) 스케줄링: Ready큐를 여러 개 사용하는 기법. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여한다.

        1-4. 다단계 피드백 큐 스케줄링: 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있다.
  
#### 비선점스케줄링

   - 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링
   - CPU를 할당받은 프로세스가 종료되거나 입출력 조작을 위해 자발적으로 중지되기 전까지 CPU할당을 보장하는 스케줄링

  * 종류

         1-1.  HRN(Highest response ratio next) 스케줄링: 긴 작업과 짧은 작업간의 지나친 불평등을 어느 정도 보완한 기법. 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정한다.

         1-2. SJF(Shortest Job First) 스케줄링: 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행. 평균 대기 시간을 감소시킨다.

         1-3. 우선순위(priority) 스케줄링: 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리한다. 
         동적으로 부여할 경우, 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킨다.

         1-4. 기한부(Deadline) 스케줄링: 작업을 명시된 시간이나 기한 내에 완료하도록 계획.

         1-5. FIFO 스케줄링: 프로세스들은 Ready큐에 도착한 순서대로 CPU를 할당 받는다. 작업 완료 시간을 예측하기 매우 용이하다. 하지만 덜 중요한 작업이 중요한 작업을 기다리게 할 수도 있다.


## 캐시 동작원리

#### 캐시
 - 메인 메모리와 CPU간의 데이터 속도 향상을 위한 중간 버퍼 역할을 하는 CPU내 또는 외에 존재하는 메모리
 - CPU는 데이터를 가져오기 위해 캐시 메모리 > 메모리 > 보조기억장치 
 - 캐시 적중일 때 : 캐시 메모리의 데이터를 CPU 레지스터에 복사한다.
 - 캐시 실패/메모리 적중일 때 : 메모리의 데이터를 캐시 메모리에 복사하고, 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사한다.
 - 캐시, 메모리 실패일 때 : 보조 기억장치에서 필요한 데이터를 메모리에 복사한다. 메모리에 복제된 내용을 캐시 메모리에 복제한다. 캐시 메모리의 복제된 데이터를 CPU 레지스터에 복제한다

* 지역성의 종류
      시간적 지역성(temporal locality) : CPU가 한 번 참조한 데이터는 다시 참조할 가능성이 높다.
      공간적 지역성(spatial locality) : CPU가 참조한 데이터와 인접한 데이터 역시 참조될 가능성이 높다.
      순차적 지역성(sequential locality) : 분기가 발생하지 않는 한 명령어는 메모리에 저장된 순서대로 인출/실행된다.

* 기본적인 동작의 흐름

      CPU가 캐시에 주소 전송 > 태그 메모리 탐색 > 일치하는 태그 발견 (hit) > 블록 상태 갱신(필요할 경우) >데이터 메모리에서 블록 추출 > 요청받은 데이터 선택 > 캐시가 CPU에 데이터 전송
      CPU가 캐시에 주소 전송 > 태그 메모리 탐색 > 일치하는 태그 없음(miss) > 주소를 메모리로 전송해 대응하는 블록을 캐시에 저장 > 요청받은 데이터 선택 > 캐시가 CPU에 데이터 전송




## 이진 트리

- 시간 복잡도는 O(logn)
- 주요 용도 : 데이터 검색
- 탐색 속도를 개선

#### 종류

* 완전 이진 트리 : 높이가 h일때 레벨 1~ h-1까지 모든 노드가 두개식 채워져 있고, 레발h는 왼쪽부터 노드가 채워져 있는 트리
* 포화 이진 트리 : 높이가 h일 때, 레벨 1 ~ h 까지 모든 노드가 두개씩 채워져 있는 트리
* 편향 이진 트리 : 왼쪽이나 오른쪽 서브 트리만 가지는 트리


#### 탐색
1. in-order(중위 순회) : 왼쪽 자식노드(L), 내 노드(P), 오른쪽 자식노드(R) 순서로 방문한다.
2. pre-order(전위 순회) : 내 노드(P), 왼쪽 자식노드(L), 오른쪽 자식노드(R) 순서로 방문한다.
3. post-order(후위 순회) : 왼쪽 자식노드(L), 오른쪽 자식노드(R), 내 노드(P) 순서로 방문한다.
4. level-order(레벨 순회) : 내 노드(P), 내 노드로부터 깊이 1인 노드들, 내 노드로부터 깊이 2인 노드들, ... , 내 노드로부터 깊이 N인 노드들 (N: 나(트리)의 깊이)
