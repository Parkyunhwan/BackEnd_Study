## 얕은 복사 vs 깊은 복사
  * 단순 객체 복사
    ```python
    # mutable 객체 (변경가능 객체(리스트, 인스턴스 변수, 딕셔너리, 배열))
    a = [1, 2, 3, 4]
    b = a     # copy
    print(b)    # [1, 2, 3, 4]
    b[2] = 100   # b의 item 변경
    print(b)    # [1, 2, 100, 4]
    print(a)    # [1, 2, 100, 4], a의 item도 수정됨!!
    
    # immutable 객체 (변경 불가능 객체(숫자, 문자열, 튜플))
    a = 10
    b = a
    print(b)    # 10 출력력
    b = "abc"
    print(b)    # abc 출력
    print(a)    # 10 출력
    ```
  * 얕은 복사
    * 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
    * 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
    * 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
    ```python
    import copy
    # immutable
    a = [1, [1, 2, 3]]
    b = copy.copy(a)    # shallow copy 발생
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100  # 숫자
    print(b)    # [100, [1, 2, 3]] 출력,
    print(a)    # [1, [1, 2, 3]] 출력, shallow copy 가 발생해 복사된 리스트는 별도의 객체이므로 item을 수정하면 복사본만 수정된다. (immutable 객체의 경우)

    # mutable
    c = copy.copy(a)
    c[1].append(4)    # 리스트의 두번째 item(내부리스트)에 4를 추가 c[1]=[1,2,3,4] : list (mutable)
    print(c)    # [1, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3, 4]] 출력, a가 c와 똑같이 수정된 이유는 리스트의 item 내부의 객체는 동일한 객체이므로 mutable한 리스트를 수정할때는 둘다 값이 변경됨
    ```
  * 깊은 복사
    * 복사본의 값이 mutable한 객체일때, 이를 변경했을 시, 원본의 값도 변경되는 현상을 해결
    * 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
    * 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.
    ```python
    import copy
    a = [1, [1, 2, 3]]
    b = copy.deepcopy(a)    # deep copy 실행 
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100 # immutable
    b[1].append(4) # mutable
    print(b)    # [100, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3]] 출력
    ```
## CPU 스케줄링
* 어떤 프로세스에 CPU를 배정할지 결정
* 목적: 공평성, 효율성, 안정성, 반응 시간 보장, 무한 연기 방지
* 종류
    * 선점형 스케줄링: 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
    * 비선점형 스케줄링: 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식
* 성능 척도
    * CPU
        * CPU 사용률: 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법으로 최대한 CPU를 바쁘게 만드는 것이다. 가장 이상적인 수치는 물론 100%다.
        * Throughput: 단위 시간당 작업을 마친 프로세스의 수다. 즉, CPU 버스트를 처리한 수다.
    * 프로세스
        * Turn-around-time(반환시간): `프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간이다.` 프로세스의 `대기 시간 + 실행시간`이다. 여기서 대기 시간은 없을 수도 있고, 1 번일 수도, 여러 번일수도 있다.
        * Waiting time(대기시간): `프로세스가 CPU를 할당받아 실행되기 전 대기 상태일 때의 시간이다.` 보통 준비 큐에서 대기를 하는 시간이다.
        * Response time(응답시간): `프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간이다.` 대기 시간과의 차이점은 대기 시간은 반환 시간과 마찬가지로 여러 번 있을 수 있다. 그 총합이 대기 시간이고, 응답 시간은 최초의 한 번이다. 이 응답 시간은 프로세스 입장에서 CPU를 한 번도 못 얻은 것과 한 번이라도 얻는 것은 사용자 응답에 있어서 중요한 차이가 있기 때문에 중요하다.
* 알고리즘 종류
    * FCFS (First Come First Served): 말 그대로 `선입선출` 방식으로, 준비 큐에 도착한 순서대로 CPU를 할당하는 `비선점형 방식`이다. 모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법이다. 하지만 CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 한없이 기다려야 하기 때문에 비효율적이게 된다. 이를 콘보이 효과라고 한다.
    * SJF (Shortest Job First): 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 `비선점형 방식`이다. 늦게 도착하더라도 CPU 처리 시간이 앞에 대기중인 프로세스보다 짧으면 먼저 CPU를 할당받을 수 있다. 때문에 콘보이 효과를 완화할 수 있다. 단, 비선점형 방식이기 때문에 CPU를 사용중인 프로세스보다 처리 시간이 짧더라도 빼앗지는 못한다. 단점으로, 일단 가장 중요한 `공평성에 어긋난다.` 처리 시간이 긴 프로세스의 경우 처리 시간이 짧은 프로세스가 계속해서 들어온다면 대기 큐에서 영영 CPU를 할당받지 못할 수 있다. 이를 `starvation 현상`이라고 한다.그리고 중간에 입출력 버스트가 빈번하게 요구되는 프로세스의 경우 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.

 


## 캐시
* [참고](https://aidanbae.github.io/code/devops/computer/cpucache/)

## 이진트리
* 부모보다 작은 값은 왼쪽 자식, 큰 값은 오른쪽 자식. 검색시 내려가면서 해당 노드보다 찾는값이 더 작으면 왼쪽에서 찾고, 찾는값이 더 크면 오른쪽에서 찾는다.
* 노드의 `왼쪽 서브트리에는 그 노드의 값보다 작은 값들`을 지닌 노드들로 이루어져 있다. 노드의 `오른쪽 서브트리에는 그 노드의 값보다 큰 값들`을 지닌 노드들로 이루어져 있다.
* 이진탐색 + 연결리스트
  * 이진탐색 : `탐색에 소요되는 시간복잡도는 O(logN)`, but `삽입,삭제가 불가능`
  * 연결리스트 : `삽입, 삭제의 시간복잡도는 O(1)`, but `탐색하는 시간복잡도가 O(N)`
* 밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
  * 삽입, 검색, 삭제 시간복잡도는 `트리의 Depth에 비례`
* 최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
  * `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
  * `레드 블랙 트리`: 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음, 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지
* 삭제
  * 자식이 없는 leaf 노드일 때 : 그냥 삭제
  * 자식이 1개인 노드일 때 : 지워진 노드에 자식노드로 대체하고 지워진 노드의 부모노드와 연결
  * 자식이 2개인 노드일 때 : 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값으로 대체