## 얕은 복사 vs 깊은 복사
  * 단순 객체 복사
    ```python
    # mutable 객체 (변경가능 객체(리스트, 인스턴스 변수, 딕셔너리, 배열))
    a = [1, 2, 3, 4]
    b = a     # copy
    print(b)    # [1, 2, 3, 4]
    b[2] = 100   # b의 item 변경
    print(b)    # [1, 2, 100, 4]
    print(a)    # [1, 2, 100, 4], a의 item도 수정됨!!
    
    # immutable 객체 (변경 불가능 객체(숫자, 문자열, 튜플))
    a = 10
    b = a
    print(b)    # 10 출력력
    b = "abc"
    print(b)    # abc 출력
    print(a)    # 10 출력
    ```
  * 얕은 복사
    * 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
    * 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
    * 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
    ```python
    import copy
    # immutable
    a = [1, [1, 2, 3]]
    b = copy.copy(a)    # shallow copy 발생
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100  # 숫자
    print(b)    # [100, [1, 2, 3]] 출력,
    print(a)    # [1, [1, 2, 3]] 출력, shallow copy 가 발생해 복사된 리스트는 별도의 객체이므로 item을 수정하면 복사본만 수정된다. (immutable 객체의 경우)

    # mutable
    c = copy.copy(a)
    c[1].append(4)    # 리스트의 두번째 item(내부리스트)에 4를 추가 c[1]=[1,2,3,4] : list (mutable)
    print(c)    # [1, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3, 4]] 출력, a가 c와 똑같이 수정된 이유는 리스트의 item 내부의 객체는 동일한 객체이므로 mutable한 리스트를 수정할때는 둘다 값이 변경됨
    ```
  * 깊은 복사
    * 복사본의 값이 mutable한 객체일때, 이를 변경했을 시, 원본의 값도 변경되는 현상을 해결
    * 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
    * 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.
    ```python
    import copy
    a = [1, [1, 2, 3]]
    b = copy.deepcopy(a)    # deep copy 실행 
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100 # immutable
    b[1].append(4) # mutable
    print(b)    # [100, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3]] 출력
    ```
## CPU 스케줄링
* [참고](https://preamtree.tistory.com/19)

## 캐시
* [참고](https://aidanbae.github.io/code/devops/computer/cpucache/)

## 이진트리
* 부모보다 작은 값은 왼쪽 자식, 큰 값은 오른쪽 자식. 검색시 내려가면서 해당 노드보다 찾는값이 더 작으면 왼쪽에서 찾고, 찾는값이 더 크면 오른쪽에서 찾는다.
* 노드의 `왼쪽 서브트리에는 그 노드의 값보다 작은 값들`을 지닌 노드들로 이루어져 있다. 노드의 `오른쪽 서브트리에는 그 노드의 값보다 큰 값들`을 지닌 노드들로 이루어져 있다.
* 이진탐색 + 연결리스트
  * 이진탐색 : `탐색에 소요되는 시간복잡도는 O(logN)`, but `삽입,삭제가 불가능`
  * 연결리스트 : `삽입, 삭제의 시간복잡도는 O(1)`, but `탐색하는 시간복잡도가 O(N)`
* 밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
  * 삽입, 검색, 삭제 시간복잡도는 `트리의 Depth에 비례`
* 최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
  * `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
  * `레드 블랙 트리`: 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음, 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지
* 삭제
  * 자식이 없는 leaf 노드일 때 : 그냥 삭제
  * 자식이 1개인 노드일 때 : 지워진 노드에 자식노드로 대체하고 지워진 노드의 부모노드와 연결
  * 자식이 2개인 노드일 때 : 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값으로 대체