# 얕은 복사, 깊은 복사

### 얕은 복사(shallow copy)

복사 시 주소 값만 복사하기 때문에 주소로 값을 참조하여 값이 변경되면 해당 값을 참조하고 있는 배열들의 값이 변경됨

- 한 쪽에서 수정 발생 시 다른쪽에도 영향을 끼침
- `= 연산자`로 a를 b에 얕은 복사 진행

```java
int[] a = new int[2];
a[0] = 2;
a[1] = 4;
int[] b = a;
b[0] = 6;
b[1] = 8;
```

### 깊은 복사(Deep copy)

- 깊은 복사는 주소값을 참조하는 것이 아닌 → 새로운 메모리 공간에 값을 복사하는 것!
- 원본 배열이 변경되어도 복사된 배열과 전혀 관련 없음

```java
public static void main(String[] args) {
    int[] arr = new int[10];
    int[] copy = deepCopyWithClone(arr);

    for (int i = 0; i < arr.length; i++) arr[i] = i;
    for (int a : arr) System.out.print(a + " ");

    System.out.println();
    copy[0] = 100;
    for (int a : copy) System.out.print(a + " ");
}

private static int[] deepCopyWithClone(int[] original) {
    if (original == null) return null;
    int[] result = new int[original.length];

    result = original.clone();
    return result;
}
```

배열.clone() 명령어를 사용하면 깊은 복사를 진행할 수 있다. (for문으로 값을 일일이 넣어줘도 됨)

# CPU 스케줄링

어떤 프로세스에 CPU를 배정할지 결정함.

- 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 함
- 효율성 : 시스템 자원을 쉬게해서 안됨
- 안정성 : 우선순위가 높은 것 먼저 처리 할 것
- 반응 시간 보장 : 응답이 없으면 멈췄다고 생각하므로 적절한 시간 안에 프로세스의 요구에 반응해야한다.
- 무한 연기 방지 : 특정 프로세스 작업이 무한히 연기되어서는 안된다

## 선점형 스케줄링

프로세스가 CPU를 할당 받아 실행중이더라도 **운영체제가 CPU를 강제로 빼앗을 수 있는 방식**

- 처리시간이 긴 프로세스가 CPU사용을 독점하는 것을 막을 수 있음
- 잦은 문맥 교환으로 인한 오버헤드 증가

## 비선점형 스케줄링

프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식

- 필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 난다.

## 스케줄링 알고리즘

### 성능 척도

- CPU 입장
    - CPU 사용률 : 동작시간 중 CPU가 사용된 시간 측정
    - Throughput : 단위 시간당 작업을 마친 프로세스 수
- 프로세스 입장
    - 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는데 걸리는 시간
    - 대기 시간 : 프로세스가 CPU를 할당받아 실행되기 전 준비 큐에서 대기하는 시간
    - 응답 시간 : 프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간 (최초 한번)

### 알고리즘 종류

- **FCFS(First Come First Served)**
    - 선입 선출 방식, 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
    - 매우 단순하고 공평한 방법

    - 하지만, CPU 처리 시간이 매우 긴 프로세스 앞에 올 경우 뒤에 프로세스는 한없이 대기해야함

- **SJF(Shortest Job First)**
    - 준비 큐에 있는 프로세스 중 **실행 시간이 가장 짧은 작업**부터 CPU를 할당하는 비선점형 방식
    - 늦게 도착하더라도 CPU처리 시간이 짧으면 먼저 CPU할당 받음

    - 실행 중인 프로세스보다 처리 시간이 짧더라도 비선점형 이기 때문에 뺏지 못함
    - FCFS에 비해 평균 대기 시간이 짧지만 계속해서 짧은 프로세스가 들어오면 뒤에 있는 프로세스는 영영 실행 못함 **(Starvation현상)**

- **HRN(Highest Response Ratio Next)**
    - SJF 스케줄링 기법에 Aging 기법을 합친 비선점형 알고리즘
    - Starvation현상을 방지하기 위해 대기 시간이 길어진 프로세스의 우선순위를 높여 실행하는 방식
    - SJF의 공평성 문제 해결

- **SRTF(Shortest Remaining Time First)**
    - SJF의 선점형 방식, 먼저 온 프로세스가 CPU를 할당 받고 있더라도 남은 처리 시간이 뒤에 온 프로세스 처리 시간보다 길면 CPU를 빼앗긴다
    - 어떠한 스케줄링 알고리즘보다 **평균 대기 시간이 짧은 알고리즘**
    - 그러나, 선점형 방식이기에 잦은 문맥교환 발생으로 오버헤드가 증가한다.
    - **가장 큰 문제는 CPU의 예상 시간을 예측하기 어렵다는 점이다.**

- **RR(Round Robin)**
    - 프로세스에게 각각 동일한 CPU 할당 시간을 부여해서 이 시간동안만 CPU를 이용하게 한다.
    - 할당 시간안에 일을 다 처리하지 못하면 CPU를 빼앗고 다음 프로세스에게 넘긴다.
    - 빼앗긴 프로세스는 준비 큐의 맨 뒤로 이동한다. (선점형 방식)

    따로 **CPU의 처리 시간을 계산하지 않아도 되는 간단한 선점형 방식이다.**

    또한, 프로세스가 n개라면 어떤 프로세스도 (n - 1)<할당시간> 이상 기다리지 않는다.

    즉, 모든 프로세스가 **최초 응답 시간을 빠르게 보장 받을 수 있다. (반응이 빠름)**

    **라운드 로빈 방식에서 "타임 슬라이스"의 크기를 적절히 조절하는 것이 중요하다.**

    짧으면 문맥교환 잦아지고 오버헤드 증가, 길다면 반응 속도 저하

- Multilevel Queue
    - 다단계 큐 스케줄링은 우선순위에 따라 **준비 큐를 여러 개 사용하는 방식**
    - 각 큐마다 독립적인 실행 알고리즘을 가짐

- Multilevel Feedback Queue
    - 다단계 큐의 공평성 문제를 완화하기 위해 우선순위를 조절하는 알고리즘
    - 우선순위 변동으로 큐 사이의 이동이 가능하다.
    - 한번 CPU를 할당받은 프로세스는 우선순위가 조금 낮아짐 (더 낮은 큐로 이동)

# 캐시 동작 원리

캐싱은 컴퓨터의 처리 성능을 높이기 위한 기법

CPU에 비해 메모리의 속도가 느리기 때문에 메모리 접근할 때 CPU는 효율적으로 사용되지 못함

### 사용이유

- **캐시 메모리는 CPU와 메모리의 속도 차이로 인한 병목 현상을 완화하기 위해 사용한다.**

[https://s3-us-west-2.amazonaws.com/secure.notion-static.com/674f874e-65b9-4515-88de-b201db1f78fe/img1.daumcdn.webp](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/674f874e-65b9-4515-88de-b201db1f78fe/img1.daumcdn.webp)

자주 접근하는 데이터를 "캐시"에 두어 빠르게 접근할 수 있도록 한다.

**캐시 메모리는 가격이 비싸기 때문에 일반적으로 작은 용량으로 구성된다.**

### 적중과 실패

CPU가 메모리에 접근하기 전 캐시 메모리를 확인하는데

이때 원하는 데이터 존재한다면 "적중(hit)", 없다면 "실패(miss)"이다.

**이때 요청한 데이터를 캐시메모리에서 찾을 확률을 적중률(hit ratio)라고 한다.**

**`적중률 = 캐시 메모리 적중 횟수 / 전체 메모리 참조 횟수`**

CPU는 데이터를 가져오기 위해 ( 캐시 메모리 → 메모리 → 보조기억장치) 순으로 접근한다.

### 참조의 지역성

- 시간적 지역성 : CPU가 한번 참조한 데이터는 **빠른 시간내에 다시 참조할 가능성이 높다.**
- 공간적 지역성 : CPU가 참조한 데이터와 **인접한 데이터 역시 참조될 가능성이 높다.**
- 순차적 지역성 : 분기가 없다면 **명령어는 메모리에 저장된 순서대로 인출된다.**

### 캐시 메모리의 기본 구성과 동작

- 캐시 메모리는 데이터를 관리하기 위해 `데이터 메모리` 와 `태크 메모리` 를 사용

- 블록 : 데이터의 기본 단위
- 데이터 메모리 : 메모리의 데이터들이 저장된 블록
- 태그 메모리 : 데이터 메모리의 블록을 **탐색할 정보를 포함**

    **태크 메모리의 엔트리는 데이터 메모리 블록과 쌍을 이룸**

    → 이 한 쌍은 "태그, 유효비트, 갱신비트"를 포함함

    - 태그 : CPU가 요청한 데이터를 탐색하는데 주소의 일부.
    - 유효 비트 : 캐시 블록이 유효한 데이터인지 나타냄
    - 갱신 비트 : 캐시로 블록을 가져온 후 CPU가 블록을 수정했는지 나타냄

**기본적인 동작의 흐름**

- CPU가 캐시에 주소 전송 > **태그 메모리 탐색** > 일치하는 **태그 발견 (hit)** > 블록 상태 갱신(필요할 경우) >데이터 메모리에서 **블록 추출** > 요청받은 데이터 선택 > **캐시가 CPU에 데이터 전송**
- CPU가 캐시에 주소 전송 > 태그 메모리 탐색 > 일치하는 태그 없음(miss) > **주소를 메모리로 전송해 대응하는 블록을 캐시에 저장** > 요청받은 데이터 선택 > 캐시가 CPU에 데이터 전송

# 이진 트리

이진트리란 자식노드가 최대 두 개인 노드들로 구성된 트리입니다.

**종류 : 정이진트리(full), 완전이진트리(complete), 균형이진트리(balanced)**

정이진 → 모든 레벨이 꽉 채워진 이진 트리

완전이진 → 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리

균형이진 → 모든 리프노드의 깊이 차이가 많아야 1인 트리
