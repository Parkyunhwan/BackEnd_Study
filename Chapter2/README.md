# 2 주차


## 1. TCP vs UDP

![image](https://user-images.githubusercontent.com/46014765/111902403-a7c3b500-8a80-11eb-8dce-e8ba1a45774f.png)

### TCP
: 인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

 [TCP 서버의 특징 ]
- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)


### UDP
: 데이터를 데이터그램 단위로 처리하는 프로토콜


[ UDP 서버의 특징 ]
- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.





## 2. HTTPS

HTTP

웹에서만 사용하는 프로토콜, TCP/IP기반으로 서버와 클라이어트 간의 요청과 응답을 전송

문제점
- 평문 통신이므로 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장가능
  - 의미없는 리퀘스트도 수신할 가능성있음 <-DoS 공격
- 완전성 증명할 수 없기 때문에 변조 가능
  - 완전성이란?  정보의 정확성, 서버 or 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다는 것을 보장
 
 => 이러한 문제점을 해결하기 위해 등장한 HTTPS
 
 ### HTTPS
: 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- 텍스트를 암호화한다
- HTTPS 통신하는 소켓 부분을 인터넷 상에서 정보하는 암호화 SSL(Secure Socket Layer)라는 프로토콜로 대체한 것
- HTTP는 TCP와 통신, HTTPS에서 HTTP는 SSL과 통신하고, SSL이 TCP와 통신함( 하나의 레이어를 더 둔것)
- SSL에서는 대칭키 암호화방식 & 공개키 암호화 방식 모두 사용함


> SSL?

웹서버와 브라우저 사이의 보안을 위해 만들어짐. CA라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는 데 사용됨

모든 웹에서 https 사용하지 않음
- CPU나 메모리 등 리소스가 많이 필요
- 서버 한 대당 처리할 수 있는 리퀘스트 수가 줄어듦

따라서, 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 함
 
 ## 3. REST API
 
 : REST란 Representational State Transfer의 약자로 웹의 장점을 최대한 활용할 수 있는 Client와 Server 간 통신 방식 중 하나
 설계 기본 규칙으로 HTTP URI를 통해 자원을 명시하고 HTTP method(GET, POST, PUT, DELETE)를 통해 자원을 처리하도록 설계된 아키텍처
 
 구성요소
- 자원(Resource) : URI
- 행위(Verb) : HTTP METHOD
- 표현(Representations)
 
 `REST`는 URI를 통해 자원을 표시하고, HTTP METHOD를 이용하여 해당 자원의 행위를 정해주며 그 결과를 받는 것
 
 ## REST API?
 : REST 기반의 규칙들을 지켜서 설계된 API를 REST API 혹은 RESTful API 라고 함
 
 
 ## RESTful API?
 : RESTful의 목적은 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
 
 CRUD
| CRUD | METHOD | /URI |
|------|---|---------|
| 표시 | GET | /users |
| 하나만 표시 | GET | /users/:id |
| 생성 | POST | /users |
| 수정 | PUT | /users:id |
| 삭제 | DELETE | /users:id |

- RESTful 하지 못한 경우
  - CRUD 기능을 전부 POST 로만 처리하는 API
  - URI에 자원과 id외 정보가 들어간경우

 
 ## 4. Quick, Merge 정렬
 
 ### Quick
 : *분할정복방법*, 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략

- 시간복잡도
  - 최선의 경우 :  O(N logN)
  - 최악의 경우 O (N^2)
 - 공간복잡도 O(n)
 
 [장점]
- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 수 있음.
- 한번 결정된 피벗들이 추후 연산에서 제외되는 특성때문에, 시간복잡도가 O(n logn)을 가짐
→ 다른 정렬 알고리즘과 비교했을 때 가장 빠름.
In place order

[단점]
- 불안정 정렬
- 정렬된 배열에 대해서는 quick sort의 불균형 분할에 의해 오히려 수행 시간 더 오래 걸림.


### Merge
:빠른 정렬로 분류되며, Quick Sort와 함께 많이 언급되는 정렬 방식
Quick Sort와는 반대로 안정 정렬에 속한다.

[장점]
- 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. -> O(N logN)
- 크기가 큰 레코드를 정렬한 경우, LinkedList를 사용한다면 병합 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적
- 안정 정렬

[단점]
- 레코드를 배열로 구성한다면, 임시 배열이 필요
- 메모리 낭비를 초래
- 제자리 정렬이 아님
- 레코드의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래

- 시간 복잡도
평균 : O(N logN)
최악 : O(N logN)
최선 : O(N logN)
 
