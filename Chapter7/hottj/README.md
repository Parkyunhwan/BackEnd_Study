# 기수 정렬
- 0~9 까지의 Bucket(Queue 자료구조의)을 준비한다.
- 모든 데이터에 대하여 가장 낮은 자리수에 해당하는 Bucket에 차례대로 데이터를 둔다.
- 0부터 차례대로 버킷에서 데이터를 다시 가져온다.
- 가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2번 3번 과정을 반복한다.
- 시간 복잡도는 O(dn)
- 자리수가 고정되어 있어서 안정성이 있는 정렬 방식
- [참고](https://lktprogrammer.tistory.com/48)

# OSI 7 계층
- 

# 시스템 콜
- 시스템 호출 이란?
    - 시스템 호출은 대부분 시스템 콜이라고 자주 쓰임
    - 시스템 콜은 응용프로그램에서 운영체제에게 어떠한 기능을 수행해 달라고 하는 하나의 수단
    - 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근 하기 위한 인터페이스
- 시스템 호출의 기능
    - 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.
    - 시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다,
    - 커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.
- 시스템 호출의 유형
    - 프로세서 제어(process Control)
    - 파일 조작(file manipulation)
    - 장치 관리(Device Management)
    - 정보 유지(Information maintenance)
    - 통신 (Communication)
- 시스템 호출 종류
    - 프로세스 와 관련된 시스템 호출
        - 프로세스 제어용
            - exec : 자신을 수행 가능한 다른 프로세스로 대치 수행
            - fork : 현재의 프로세스 이미지를 복사하고 child 프로세스를 만듬
            - wait
        - pipe : 파이프
        - signal : 소프트웨어 인터럽트 또는 시그널
        - exit : 프로세스 종료
        - getuid, setuid ... : 사용자 및 그룹 id 접근
    - 표준 화일 (장치)에 대한 입출력 시스템 호출
        - open( ), create( ), close( ), read( ), write( ), lseek( ), ...
    - 소켓 기반의 입출력 시스템 호출
        - socket( ), bind( ), listen( ), accept( ), connect( ), ...
- [참고](https://ypangtrouble.tistory.com/entry/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9CSystem-Call)

# 스프링의 큰 특징들

# 스프링 디자인(mvc1, mvc2 등)
- JSP
    - Java + HTML
    - 동적 웹페이지를 생성하는 언어
- JSP Model1
    - 로직 + 출력 코드가 한 페이지에 삽입
    - 쉬운 코딩
    - 어려운 유지보수
    - 뷰와 로직이 섞인다
    - 구조가 단순
- JSP Model2
    - MVC 패턴을 웹에 적용
    - 비지니스/출력 로직의 분리
    - 유지 보수가 용이
    - 뷰, 로직에 대한 분업이 가능
    - 모델1에 비해 습득이 어렵고 작업량이 많다
- Cocoa MVC
    - Model과 View의 완전한 분리
    - 현재 개발자들에게 가장 친숙
- MVC
    - 클라이언트는 필요한 기능을 컨트롤러에게 요청
    - 컨트롤러는 알맞은 모델에게 비지니스 로직 수행을 맡김
    - 알맞은 뷰 선택
    - 결과 화면 출력
- 모델
    - 값 기능을 갖는 객체
    - 비니지스 로직 수행
        - 상태 변화 처리
        - 상태 정보 변환
- 뷰
    - 모델에 포함된 데이터의 시각화
    - 모델이 처리한 데이터를 받아서 사용
    - 데이터, 로직 x
- 컨트롤러
    - 사용자의 요청을 해석하여 처리하고 결과를 반환
    - 모델과 뷰의 역할을 분리
    - 데이터의 흐름 제어
        - 컴포넌트 정보들을 앎
- 사용 이유
    - 각 컴포넌트의 코드 결합도를 낮춤
    - 구성요소들의 재사용
    - 확장성 증가
        - 모델은 그대로, 컨트롤러와 뷰만 변경해서 끼우면됨
    - 중복 코딩 제거
    - 각 요소들에 집중
        - 분업
- 단점
    - 모델과 뷰의 강한 결합
        - 뷰를 수정하면 모델을 같이 고쳐야함
- MVP
    - 모델 + 뷰 + 프레젠터
    - 강한 결합을 없애기 위해 뷰의 인터페이스와 결합
- MVVM
    - 뷰 모델 테스트가 용이해지고 의존성이 낮아짐
- [참고](https://beomy.tistory.com/43)
- [MVC](https://m.blog.naver.com/jhc9639/220967034588)
