# 기수 정렬
- 0~9 까지의 Bucket(Queue 자료구조의)을 준비한다.
- 모든 데이터에 대하여 가장 낮은 자리수에 해당하는 Bucket에 차례대로 데이터를 둔다.
- 0부터 차례대로 버킷에서 데이터를 다시 가져온다.
- 가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2번 3번 과정을 반복한다.
- 시간 복잡도는 O(dn)
- 자리수가 고정되어 있어서 안정성이 있는 정렬 방식
- [참고](https://lktprogrammer.tistory.com/48)

# OSI 7 계층
- 두 대의 컴퓨터가 통신하려면?
    - 0과 1만 주고받으면됨
        - 5v -> 1
        - -5v -> 0 
        - 실제에선 잘 안됨
            - 모든 전기신호를 통과시킬 수 있는 전선이 없음
                - 아날로그로 변환해서 보내야함
- 1계층 피지컬 레이어
    - 0과 1의 나열을 아날로그 신호로 바꾸어 전선으로 흘려 보내고, (인코딩)
    - 아날로그 신호가 들어오면 0과 1의 나열로 해석하여 (디코딩)
    - 물리적으로 연결된 두 대의 컴퓨터가 0과 1의 나열을 주고받을 수 있게 해주는 모듈 (모듈)
    - 하드웨어적으로 구현되어있음
- 2계층 사전지식
    - 여러 대의 컴퓨터가 통신하려면?
        - 전선을 많이 꽂는다?
            - 통신하려는 컴퓨터가 많아지면 비용면에서 비효율적
        - 전선 하나를 가지고 여러 대의 컴퓨터와 통신할 방법을 모색해야함
            - 가운데 구리선 하나로 모든 곳에 신호가 전달되게함
            - 가운데 구리선을 상자로 대치함(더미 허브)
                - 이 더미 허브로 모든 컴퓨터와 연결해서 통신하게끔 함
                - 이는 보안상 문제가 될 수 있음. 모두에게 전송될 수 있으므로
                - 상자가 메시지의 목적지를 확인해서 모두에게 보내지 않고 목적지에만 보낼 수 있게 해야함
                    - 이게 스위치
                    - 스위치에 연결된 컴퓨터들을 네트워크라고 한다
        - 스위치 끼리 연결해서 서로 다른 네트워크에 속한 컴퓨터끼리 통신이 가능하게해주는 장비를 라우터라고 함    
            - 라우터가 바로 공유기이다
        - 라우터들을 연결하여 전 세계의 컴퓨터들을 연결한 것을 인터넷이라고 한다
- 2계층 데이터 레이어
    - 스위치 하나로 데이터가 010101111..로 왔을때, 이를 제대로 끊어 읽어야함
        - 송신자는 데이터의 앞뒤에 특정한 비트열을 붙여서 보냄 (Framing) ex) 1111 + 데이터 + 0000
        - 수신자는 끝과 시작 비트열을 찾아내어 데이터를 꺼낸다
    - 같은 네트워크에 있는 여러 대의 컴퓨터들이 데이터를 주고 받기 위해서 필요한 모듈
    - 프래이밍은 데이터 링크 계층에 속하는 작업들 중 하나
    - 랜카드에 구현되어있음 (하드웨어적)
- 3계층 네트워크 레이어
    - 더 많은 컴퓨터들 사이의 통신
        - 데이터앞에 목적지 주소를 붙인다 ex) 55.10.54.75 + data
        - 각 컴퓨터들이 갖는 고유한 주소를 IP주소라고 함
        - 목적지 주소를 어떻게 아는가?  
            - 주소창에 www.naver.com을 입력하면, 이 영어주소는 ip주소로 변환되어 사용됨(즉 우리는 네이버의 ip주소를 알고 있는 것과 마찬가지인셈)
        - 55.10.54.75 data : 패킷
    - A가 라우터가에게 패킷 전송
    - 라우터가는 나와 연결된 컴퓨터중에는 목적지 컴퓨터가 없다고 판단
    - 가는 데이터를 다시 포장한 뒤, 자신과 연결되어 있는 유일한 라우터인 마에게 전달
    - 마 역시 목적지 주소읽고 어디로 보내야할지 찾음
        - 가에게 보내야할지 나에게 줘야할지 바에게 줘야할지 모름
            - 라우팅에 대해 공부
    - 라우터바에게 데이터를 줘야한다는 것을 판단
    - 수 많은 네트워크들의 연결로 이루어지는 인터네트워크 속에서 어딘가에 있는 목적지 컴퓨터로 데이터를 전송하기 위해 ip주소를 이용해서 길을 찾고 (라우팅) 자신 다음의 라우터에게 데이터를 넘겨준다 (포워딩)
    - 운영체제의 커널에 소프트웨어적으로 구현됨
- 4계층 트랜스포트 레이어
    - 컴퓨터는 데이터들을 받고 이 데이터들을 프로세스들에게 나누어 주려고 한다
    - 어떤 데이터를 무슨 프로세스에게 줘야할지 컴퓨터가 어떻게 알 수 있을까?
    - 데이터를 받고자 하는 프로세스들은 포트 번호라는 것을 가져야함
    - 포트번호는 하나의 컴퓨터에서 동시에 실행되고 있는 프로세스들이 서로 겹치지 않게 가져야하는 정수값
    - 송신자는 데이터를 보낼때 데이터를 받을 수신자 컴퓨터에 있는 프로세스의 포트 번호를 붙여서 보냄
    - www.naver.com 은 사실 뒤에 :80이 생략된것. 네이버의 포트번호도 알고있는셈이다.
    - 포트번호를 사용하여 도착지 컴퓨터의 최종 도착지인 프로세스에까지 데이터가 도달하게 되는 모듈
    - 운영체제의 커널에 소프트웨어적으로 구현됨
- 5계층 어플리케이션 레이어
    - 왜 5계층까지?
        - 현대의 인터넷은 osi7이 아니라 tcp/ip 모델을 따름.
    - tcp/ip 소켓 프로그래밍
        - 운영체제의 트랜스포트 레이어에서 제공하는 api를 활용해서 통신 가능한 프로그램을 만드는 것을 tcp/ip 소켓 프로그래밍 또는 네트워크 프로그래밍이라고함
    - http
    
# 시스템 콜
- 시스템 호출 이란?
    - 시스템 호출은 대부분 시스템 콜이라고 자주 쓰임
    - 시스템 콜은 응용프로그램에서 운영체제에게 어떠한 기능을 수행해 달라고 하는 하나의 수단
    - 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근 하기 위한 인터페이스
- 시스템 호출의 기능
    - 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.
    - 시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다,
    - 커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.
- 시스템 호출의 유형
    - 프로세서 제어(process Control)
    - 파일 조작(file manipulation)
    - 장치 관리(Device Management)
    - 정보 유지(Information maintenance)
    - 통신 (Communication)
- 시스템 호출 종류
    - 프로세스 와 관련된 시스템 호출
        - 프로세스 제어용
            - exec : 자신을 수행 가능한 다른 프로세스로 대치 수행
            - fork : 현재의 프로세스 이미지를 복사하고 child 프로세스를 만듬
            - wait
        - pipe : 파이프
        - signal : 소프트웨어 인터럽트 또는 시그널
        - exit : 프로세스 종료
        - getuid, setuid ... : 사용자 및 그룹 id 접근
    - 표준 화일 (장치)에 대한 입출력 시스템 호출
        - open( ), create( ), close( ), read( ), write( ), lseek( ), ...
    - 소켓 기반의 입출력 시스템 호출
        - socket( ), bind( ), listen( ), accept( ), connect( ), ...
- [참고](https://ypangtrouble.tistory.com/entry/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9CSystem-Call)

# 스프링의 큰 특징들
- 사용 이유
    - 시스템 개발시 비지니스 로직 이외에도 고려할 사항들이 많음(타시스템과의 연계, 분산 트랜잭션 지원, 보안 등)
    - 비지니스 로직이 점점 복잡해지고 잦은 변경이 요구
    - 이를 해결하기 위해 DI, AOP, PSA 특징을 갖고 있는 스프링이 요구
- 서블릿
    - 웹 애플리케이션을 만들 때 필요한 인터페이스
- 스프링 웹 mvc
    - 스프링 프레임워크에 있는 모듈
    - 웹 서비스를 만듦
    - mvc 패턴 사용
    - 얘가 서블릿을 사용함
- 초기에 웹서버는 정적 데이터만 전달함
    - 사용자 요청에 따라 다른 처리를 해줄 수 없음
    - 동적인 처리를 해주는 웹앱이 없다
- 동적 처리를 하기 위해 CGI 등장
    - 웹서버와 프로그램 사이의 규약
    - 사용자 증가
    - 하지만, 많은 사용자를 처리하기엔 무리
        - 리퀘스트가 들어올때마다 프로세스가 생성됨
            - 프로세스를 스레드로
    ![image](https://user-images.githubusercontent.com/47052106/115960762-329b4200-a54e-11eb-9858-325541cc49d6.png)
    - 같은 CGI 구현체라도 스레드가 다르면, CGI가 스레드당 하나씩 생성됨
        - 여러 인스턴스에서 싱글톤으로
            - 이게 바로 서블렛
    ![image](https://user-images.githubusercontent.com/47052106/115960779-45157b80-a54e-11eb-9577-2354bcc6d131.png)
- WAS
    - 웹컨테이너
        - 요청이 들어오면 요청마다 스레드를 생성하고, 서블릿을 실행
        - 서블릿 인터페이스에 따라 서블릿을 관리함
        - 서블릿 언터페이스에는 메소드가 정의되어 있어 이를 호출해줌
- 서블릿 인터페이스 메소드
    - init
        - 서블릿 인스턴스 생성
    - Service
        - 실제 기능이 수행
        - http method에 따라 doGet,doPost,doPut,doDelete 메소드를 호출
            - doXXX : 개발자가 구현
    - Destroy
        - 서블릿 인스턴스가 사라진다
        - 보통 컨테이너가 종료되는 시점에 destroy() 호출
        - 특정 서블릿 로드/언로드 시에도 사용
    - 각 메서드는 서블릿 컨테이너(톰켓)가 호출해준다
- 서블릿,url을 web.xml에 먼저 등록해야함
- 스프링 웹 mvc에서는 서블릿을 어떻게 사용?
    - dispatcher servlet
        - 모든 요청이 들어왔을때, dispatcher servlet으로 간다
        - 요청에 따라 적절한 컨트롤러를 찾는다(핸들러 매핑을 통해)
            - 찾는 방법은 스프링 프레임워크에서 제공
            - 방식은 설정파일에 지정
            - 서블릿을 등록하면 그 서블릿이 사용할 설정파일이 자동으로 등록됨
        - 핸들러 매핑에서 찾은 컨트롤러의 메서드를 호출함(modelandview 형태로 바꿔줌)
        - 뷰 이름으로 실제 뷰 객체를 생성
        - 뷰에 모델을 포함시킴
        - dispatcher servlet이 클라이언트에게 뷰를 보냄
- mvc가 없으면?
    - url마다 서블릿을 생성
    - web.xml로 서블릿 관리(요청마다 매핑을 일일이 해줘야함)
    - 서블릿에서 뷰로 보내주는 것까지 다 처리함
- 있으면?
    - 서블릿은 dispatcher servlet 하나로 생성하므로 관리 용이
    - 모델, 뷰, 컨트롤러가 독립적으로 분리됨

## IOC / DI
- 스프링의 대삼각형
    - IOC /DI
    - AOP
    - PSA
- [참고](https://galid1.tistory.com/493?category=769011)

## PSA
- [참고](https://velog.io/@jbb9229/springpsa)

## 디자인 패턴
- 싱글톤
    - 클래스 객체가 해당 프로세스 내에서 딱 하나만 만들어져야함
    - 다크모드가 어떤 페이지에 있던 그대로 유지되어있어야함
    - 인터페이스 / 레이지로딩으로 할 수 있는게 많다
    - 멀티스레드에 안전하게 사용해야함
- 전략패턴
    - 프로그램 실행 중 모드가 바뀔 때마다 검색이 이뤄지는 방식, 즉 전략이 수정
    - 모드마다의 동작 하나하나를 모듈로 따로 분리해서, 이 버튼들을 누를때마다 실행될 검색 모듈을 갈아끼워주는 방식
- 어댑터 패턴
    - 형식이 다른 둘 사이에 연결돼서 이 둘이 호환될 수 있도록 해줌
- 프록시 패턴
    - 인터넷을 연결해야해서 시간이 많이걸리거나 메모리를 많이 차지하거나 하는 등의 이유로 객체로 여럿 생성하기가 부담이 되는 것들이 있다
    - 이럴때 프록시 클래스를 따로 두어서, 가벼운 일은 얘가 처리하고 무거운 일은 실제 클래스를 생산해서 사용
    - 유튜브 동영상 프리뷰

## 스프링 디자인 패턴
- 사전지식
    - 디자인 패턴의 구현 방식
        - 상속
        - 인터페이스
        - 합성(다른 객체를 속성을 가짐)
        - 위임
    - 다 비슷해보임
- 어댑터 패턴
    - 클라이언트서버에서 클라이언트가 원하는 규격과 서비스가 제공하는 규격이 다를 때
    - 변환기를 제공해 서비스가 제공하는 규격을 클라이언트가 원하는 규격으로 변환해서 제공
    - OCP
        - 어댑터가 들어옴으로써 클라이언트나 서비스가 변경되지 않지만 클라이언트가 다양한 서비스를 제공받을 수 있으므로 확장에는 열려있음
    - 스프링의 PSA에서 사용
        - 일관성있는 서비스 패턴
    - 서비스1과 서비스2를 각각 어탭더로 감싸면, 서로 다른 인터페이스를 제공하지만 같은 메소드 명으로 호출가능해짐
- 프록시 패턴
    - 서비스가 제공하는 규격에 별도의 로직을 처리해서 제공하고 싶을 때
    - 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴
    - 클라이언트가 요청을 하면 프록시가 먼저 요청을 받고 나중에 서비스가 요청을 받는다
    - 제목은 프록시가, 프리뷰 보여주는건 실제 클래스가 담당하도록 해서 프록시 객체로 생성된 썸네일에 커서를 올릴 때 실제 클래스가 호출돼서 프리뷰를 보여주게함

# 스프링 디자인(mvc1, mvc2 등)
- JSP
    - Java + HTML
    - 동적 웹페이지를 생성하는 언어
- JSP Model1
    - 로직 + 출력 코드가 한 페이지에 삽입
    - 쉬운 코딩
    - 어려운 유지보수
    - 뷰와 로직이 섞인다
    - 구조가 단순
- JSP Model2
    - MVC 패턴을 웹에 적용
    - 비지니스/출력 로직의 분리
    - 유지 보수가 용이
    - 뷰, 로직에 대한 분업이 가능
    - 모델1에 비해 습득이 어렵고 작업량이 많다
- Cocoa MVC
    - Model과 View의 완전한 분리
    - 현재 개발자들에게 가장 친숙
- MVC
    - 클라이언트는 필요한 기능을 컨트롤러에게 요청
    - 컨트롤러는 알맞은 모델에게 비지니스 로직 수행을 맡김
    - 알맞은 뷰 선택
    - 결과 화면 출력
- 모델
    - 값 기능을 갖는 객체
    - 비니지스 로직 수행
        - 상태 변화 처리
        - 상태 정보 변환
- 뷰
    - 모델에 포함된 데이터의 시각화
    - 모델이 처리한 데이터를 받아서 사용
    - 데이터, 로직 x
- 컨트롤러
    - 사용자의 요청을 해석하여 처리하고 결과를 반환
    - 모델과 뷰의 역할을 분리
    - 데이터의 흐름 제어
        - 컴포넌트 정보들을 앎
- 사용 이유
    - 각 컴포넌트의 코드 결합도를 낮춤
    - 구성요소들의 재사용
    - 확장성 증가
        - 모델은 그대로, 컨트롤러와 뷰만 변경해서 끼우면됨
    - 중복 코딩 제거
    - 각 요소들에 집중
        - 분업
- 단점
    - 모델과 뷰의 강한 결합
        - 뷰를 수정하면 모델을 같이 고쳐야함
- MVP
    - 모델 + 뷰 + 프레젠터
    - 강한 결합을 없애기 위해 뷰의 인터페이스와 결합
- MVVM
    - 뷰 모델 테스트가 용이해지고 의존성이 낮아짐
- [참고](https://beomy.tistory.com/43)
- [MVC](https://m.blog.naver.com/jhc9639/220967034588)
