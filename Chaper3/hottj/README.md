# 데이터베이스

## 정의
- 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합

## 사용 이유

- 파일 시스템의 문제점을 해결하기 위해 사용
- 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
- 데이터 중복, 비일관성, 검색 등의 문제 존재 -> 중복 최소화, 보안성, 계속적 변화에 대한 적응
- DB는 원자적 갱신, 동시성 제어, 데이터 보호, 백업 및 회복 등의 여러 데이터 관리 기능을 두어 데이터 관리를 편하게 하기 때문에 사용

## 테이블
- 행과 열로 이루어진 데이터의 집합

## 도메인
- 데이터베이스 필드에 채워질 수 있는 값들의 집합

## 행
- 테이블을 구성하는 데이터 셋으로 튜플이나 레코드라고 불림

## 열
- 테이블을 구성하는 데이터 셋으로 속성이라고 불림

## 뷰
* 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용하게 하여 특정 속성을 숨김
* 메모리에 물리적으로 존재하지 않는 가상 테이블

## 스키마와 테이블의 차이
* `스키마는 테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더, 데이터의 구조와 구성을 설명
* `테이블은 행과 열로 구성된 데이터 집합`

## 후보 키
* 릴레이션을 구성하는 속성들 중에서 Tuple을 `유일하게 식별`할 수 있는 속성들의 부분 집합
* null 인정
* 유일

## 주 키
* 후보 키 중에서 선택한 Main Key
* notnull
* 유일

## 외래 키
* 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
* 참조되는 릴레이션의 `주 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
* 사용 이유: 테이블을 연결, 중복 방지
  * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거

# 데이터베이스 인덱스

## Index를 사용하는 이유와 장점 및 단점
* 인덱스는 추가적인 쓰기와 저장 공간 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
* 테이블 내의 `칼럼의 값(Key)`과 해당 `Key의 레코드가 저장된 주소`를 `키와 값의 쌍으로 정의`
* 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음

## Index 자료구조
* B 트리

  ![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
  * 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
  * 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
  * Branch 노드: Key와 Data 저장
* B+ 트리

  ![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)
  * B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가시킨 자료구조
  * B 트리보다 풀 스캔 빠름
  * Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능
  * Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결(부등호를 사용한 순차 검색에 유용)

* 해시 테이블
  * 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
  * O(1)로 매우 빠름
  * 인덱싱에선 부등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐
  * `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음

## Clustered-Index vs Non-Clustered-Index
* Non-Clustered Index
  * 물리적으로 재배열 하지 않는다
  * 인덱스 키 값에는 해당 데이터에 대한 포인터가 존재
    * 인덱스의 구조는 데이터 행과 독립적
    * 한 테이블에 여러 개 생성 가능
  * 리프노드에 있는 테이블 번호를 통해 해당 테이블로 가서 찾고자하는 데이터의 주소를 찾아 검색

* Clustered Index
  * 물리적으로 정렬이 되어 있는 상태로 데이터가 저장
  * 데이터를 인덱스로 지정한 컬럼에 맞춰서 정렬
    * 테이블 구조에 영향을 미치는 인덱스
    * 한 테이블에 하나만 생성 가능
  * 클러스터 키로 검색 시 처리 성능이 매우 빠름

# 쿼리

## SQL

* DML: 데이터를 조작
  |명령어|설명|
  |:---:|:---|
  |SELECT|DB의 데이터 조회 및 검색|
  |INSERT|데이터 삽입|
  |UPDATE|데이터 수정|
  |DELETE|데이터 삭제|
* DDL: 데이터(구조, 객체)를 정의
  |명령어|설명|
  |:---:|:---|
  |CREATE|DB의 테이블 생성|
  |DROP|테이블 삭제|
  |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
  |ALTER|테이블 수정|
  * DROP과 TRUNCATE의 차이
* DCL: 데이터 제어
  |명령어|설명|
  |:---:|:---|
  |GRANT|객체에 대한 권한 부여|
  |REVOKE|객체에 대한 권한 회수|
  |COMMIT|트랜잭션의 결과 반영|
  |ROLLBACK|트랜잭션 취소 및 원상 복구|

## 쿼리문 활용
- [쿼리문 활용](https://github.com/Hott-J/DataBase/blob/main/MySQL_Basic_Example.sql)

## Commit과 Rollback
* Rollback: 트랜잭션의 실행을 취소하였음을 알리는 연산자로 `트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산`

## SQL Injection
* 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
* view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 입력값 검증, Prepared Statement 사용(쿼리에 대한 컴파일을 먼저 수행하고, 입력값을 나중에 넣는 방식)

## 힌트(Hint)
* SQL을 튜닝하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것

