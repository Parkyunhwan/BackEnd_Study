# 객체 지향의 설계원칙

- 필요성
  객체 지향의 4대 특성을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙
  변화에 유연하게 대처할 수 있는 설계 원칙
 
## 객체지향

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고
그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

## 4대 특성
1. 추상화 
  - 불필요한 정보는 숨기고 중요한 정보만을 표현-> 공통의 속성이나 기능을 묶어 이름을 붙이는 것
2. 캡슐화
  - 코드를 재수정없이 재활용하는 것이 목적
3. 상속
  - 부모 클래스의 속성과기능을 그대로 이어받아 사용할 수 있게 하고
    기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당기능만 다시 수정(정의)하여 사용할 수 있게 하는것
4. 다형성
  - 하나의 변수명,함수명 등이 상황에 따라 다른 의미로 해석될 수 있다는 것
  - Overriding, Overloading



## SOLID 원칙
- 단일 책임 원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아준다.
    - 객체가 단일 책임을 가지고 클라이언트 마다 다른 인터페이스를 사용하게 함으로써 한 기능의 변경이 다른곳에 미치는 영향을 최소화할 수 있고 이는 변경을 보다 쉽게 할 수 있도록 만들어 준다.
- 리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원한다.
- 추상화를 도와주는 부분이 의존 역전 원칙이고, 다형성을 도와주는 원칙이 리스코프 치환 원칙인 것이다.

1. SRP, 단일책임원칙
  - 객체는 단 하나의 책임만 가져야 한다.
  - 클래스에 목적과 취지에 맞는 속성과 메서드로 구성. 추상화

2. OCP, 개방폐쇄원칙
  - 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적
  - 캡슐화를 통해 여러 객체에서 사용하는 같은 기능을 인터페이스에 정의

3. LSP, 리스코프치환원칙
  - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.

4. ISP, 인터페이스분리원칙
  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
  
5. DIP, 의존역전원칙
  - 객체들이 서로 정보를 주고 받을 때, 의존관계가 형성되는데 이때 객체들은 나름의 원칙을 갖고 정보를 주고받아야한다.

# HTTP METHOD
- Get
    URI(URL)가 가진 정보를 검색하기 위해 서버 측에 요청하는 형태

- POST
    요청 URI(URL)에 폼 입력을 처리하기 위해 구성한 서버 측 스크립트(ASP,PHP,JSP 등) 혹은 
    CGI 프로그램으로 구성되고, FORM Action과 함께 전송되는데
    헤더정보에 포함되지 않고, 데이터 부분에 요청정보가 들어가게된다.

- HEAD
    GET과 유사한 방식이나 웹 서버에서 헤더 정보 이외에는 어떤 데이터도 보내지 않는다.
    웹서버의 다운 여부 점검이나 웹서버 정보(버전등)등을 얻기 위해 사용될 수 있다.

- OPTIONS
    해당 메소드를 통해 시스템에서 지원되는 메소드 종류를 확인할 수 있다.

- PUT
    POST와 유사한 전송 구조를 가지기 때문에 헤더 이외의 메시지(데이터)가 함께 전송
    원격지 서버에 지정한 콘텐츠를 저장하기 위해 사용되며 홈페이지 변조에 많이 악용

- DELETE
    원격지 웹 서버에 파일을 삭제하기 위해 사용되며 PUT과는 반대 개념의 메소드

- TRACE
    원격지 서버에 Loopback(루프백) 메시지를 호출하기 위해 사용

- CONNECT
    웹 서버에 프락시 기능을 요청할 때 사용된다.
    
    
    
 # 정렬
 
 ## 거품정렬

매번 연속된 두개의 인덱스를 비교
비교시마다 큰값이 뒤로 교체되고 다음인덱스로 이동 후 비교

> 평균 및 최악 실행 시간: O(n²)
> 메모리(공간 복잡도): O(1)

- 단점

    -가장 왼쪽에 있는 하나의 값이 가장 오른쪽으로 이동하기위해서는 배열의 모든 다른 요소들과 교체되어야 함
    -일반적으로 자교의 교환(swap)작업이 자료의 이동(move)작업보다 더 복잡하기 때문에 거의 쓰지 않음

- 시간 복잡도
    1. 최선의 경우: 자료가 이미 정렬되어 있는 경우 - `O(n²)`
        - 비교 횟수: `n-1, n-2, … , 2, 1 번 = n(n-1)/2`
        - 교환 횟수: 일어나지 않음
    2. 최악의 경우 : 자료가 역순으로 정렬되어 있는 경우 - `O(n²)`
        - 비교 횟수 : `n(n-1)/2 번`
        - 교환 횟수 : `n(n-1)/2 번`


# 삽입정렬

가장 앞쪽에 있는 원소는 이미 정렬이 됐다고 가정한다.
아직 작업하지 않은 원소를 이미 정렬 완료된 앞의 원소보단 크고, 뒤에 원소보단 작은 위치에 삽입하는 방법이다.

> 평균 및 최악 실행 시간: O(n²)
메모리(공간 복잡도): O(1)

- 단점
    배열의 크기가 커질수록 효율이 떨어진다

- 시간복잡도
    최선의 경우: 자료가 이미 정렬되어 있는 경우 O(n)
  
  
  
  
# 선택정렬

첫번째 자리에 가장 적은 것을 넣는 것
버블정렬보다 보통 2개 정도 빠름

> 평균 및 최악 실행 시간: O(n²)
> 메모리(공간 복잡도): O(1)

- 단점
    성능이 좋지 않으나 작은수에서는 효율적
- 시간복잡도
    최악, 최선, 평균 항상 n(n-1) / 2번의 비교 연산을 수행하게 되므로 O(n²)이다.
    - `T(n) = (n-1) + (n-2) + … + 2 + 1 = O(n²)`


