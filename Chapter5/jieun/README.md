# 정규화와 이상현상

## 이상현상(anomaly)

📌 삭제 이상 Delete Anomaly

: 튜플 삭제시 연쇄삭제가 발생하는 현상.

ex) 학번 1602의 서현진학생이 A01 과목을 취소할 경우,

취소 사유를 물을 수 있는 유일한 정보인 연락처마저 잃게 된다.
<br> </br>

📌 삽입 이상 Insert Anomaly

: 튜플 삽입시 지정하지 않은 속성값이 NULL을 갖는 현상.

ex) 학번 1602의 서현진학생의 전화번호만 추가하고 싶을 때,

과목코드가 비게되므로 NULL값을 가져 문제가 발생한다.
<br> </br>

📌 갱신 이상 Update Anomaly

: 데이터 갱신시 일관성 유지가 안되는 현상.

ex) 최유정 학생이 연락처를 바꿨을 경우,

B01, C01 모두 갱신해야하는데 B01만 갱신할 경우 발생한다.
<br> </br>

## 데이터 정규화
:관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 **나쁜** 릴레이션의 애트리뷰트들을 나누어서 **좋은** 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재한다.

#### 2-1. ‘나쁜' 릴레이션은 어떻게 파악하는가?

엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성(Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.

#### 2-2. 함수적 종속성이란 무엇인가?

함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다. X 와 Y 를 임의의 애트리뷰트 집합이라고 할 때, X 의 값이 Y 의 값을 유일하게(unique) 결정한다면 "X 는 Y 를 함수적으로 결정한다"라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 애트리뷰트들간의 함수적 종속성을 판단할 수 있다.
_cf> 애트리뷰트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다._

#### 2-3. 각각의 정규형은 어떠한 조건을 만족해야 하는가?

1.  분해의 대상인 분해 집합 D 는 **무손실 조인** 을 보장해야 한다.
2.  분해 집합 D 는 함수적 종속성을 보존해야 한다.

</br>

### 제 1 정규형

애트리뷰트의 도메인이 오직 `원자값`만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.

### 제 2 정규형

모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 **완전 함수적 종속이면** 제 2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 `X -> Y` 라고 가정했을 때, X 의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.

### 제 3 정규형

어떠한 비주요 애트리뷰트도 기본키에 대해서 **이행적으로 종속되지 않으면** 제 3 정규형을 만족한다고 볼 수 있다. 이행 함수적 종속이란 `X - >Y`, `Y -> Z`의 경우에 의해서 추론될 수 있는 `X -> Z`의 종속관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.

### BCNF(Boyce-Codd) 정규형

여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다.

_각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다._

* 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
* 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
* 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.

수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.

</br>

### 3. 정규화에는 어떠한 장점이 있는가?

1.  데이터베이스 변경 시 이상 현상(Anomaly) 제거
    위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다.

2.  데이터베이스 구조 확장 시 재 디자인 최소화
    정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.

3.  사용자에게 데이터 모델을 더욱 의미있게 제공
    정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.

</br>

### 4. 단점은 없는가?

릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다.
조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

</br>

### 5. 단점에서 미루어보았을 때 어떠한 상황에서 정규화를 진행해야 하는가? 단점에 대한 대응책은?

조희를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.

#### 반정규화(De-normalization, 비정규화)

`반정규화`는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.

#### 5-1. 무엇이 반정규화의 대상이 되는가?

1.  자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
2.  테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
3.  테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

#### 5-2. 반정규화 과정에서 주의할 점은?

반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.

</br>

# JVM, JDK, JRE

## JVM(Java Virtual Machine)

- 스택 기반의 가상 머신.
- JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행하는 것이다.
- Java와 OS 사이에서 중개자 역할을 수행하여 Java가 OS에 구애받지 않고 재사용 가능하게 해준다.
- 메모리 관리, Garbage Collection(GC를 통해 자원을 관리)을 수행한다.
- 자바 바이트 코드를 실행할 수 있는 주체이다.



**[JVM을 알야아 하는 이유는 뭘까?]**

-> 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서라 할 수 있다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라서 성능이 좌우되기 때문에 JVM이 하는 역할을 이해하고 메모리를 효율적으로 사용하여 최고의 성능을 낼 수 있을 것이다.



**[자바 프로그램 실행 과정]**

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
   JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러(javac)가 자바 소스 코드를 읽어들여 자바 바이트 코드(.class)로 변환시킨다.
3. Class Loader를 통해 class 파일들을 JVM으로 로딩한다. 
4. 로딩된 class 파일들은 Execution Engine을 통해 해석된다.
5. 해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다. 
   이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC 같은 관리 작업을 수행한다.


<img src = "https://user-images.githubusercontent.com/33534771/83471568-f7200100-a4bf-11ea-810f-3ea08018317f.png" width="70%" />


### 각각의 역할



**[Class Loader(클래스 로더)]**

- Runtim시에 JVM내로 클래스(.class 파일)를 로드하고 링크를 통해 배치하는 작업을 수행한다. (Runtime : 클래스를 처음으로 참조할 때.)
- 사용하지 않는 클래스들은 메모리에서 삭제한다.
- 동적 로드를 담당한다.



**[Execution Engine(실행 엔진)]**

- 클래스를 실행시키는 역할이다.
- 클래스 로더가 JVM 내의 Runtime Data Area에 바이트 코드를 배치시키고 이것은 실행 엔진에 의해서 실행된다.
- 자바 바이트 코드는 비교적 인간이 보기 편한 형태로 기술된 것이다. 그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다. 
- 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
- 2가지 방식이 존재한다.
  - 최초의 JVM은 인터프리터 방식이었기 때문에 속도가 느린 단점이 존재했지만, JIT 컴파일러 방식을 통해 이 점을 보완했다. 

1) Interpreter(인터프리터)

- 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
- 한 줄씩 실행하기 때문에 느리다.

2) JIT(Just-In-Time) Compiler

- 인터프리터 방식의 단점을 보완하기 위해 등장했다.
- 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다.
- 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행된다.
- 한 번만 실행되는 코드라면 JIT 컴파일러가 컴파일하는 게 인터프리팅하는 것보다 오래 걸리므로 인터프리팅하는 것이 유리하다.
- 이처럼 해당 메소드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넘을 때만 컴파일을 수행하는 게 좋다. 



**[Garbage Collector]**

- GC를 수행하는 모듈이 존재한다.



**[Runtime Data Area]**

- JVM이 프로그램을 수행하기 위해 OS로부터 할당받은 메모리 공간이다.
- 이 공간은 용도에 따라 여러 영역으로 나누어 관리한다.

<img src = "https://user-images.githubusercontent.com/33534771/83472428-2fc0da00-a4c2-11ea-90a9-dac474fada4b.png" width ="70%"/>


1. PC Register

   - Thread가 시작될 때, 각각의 Thread 별로 생성되는 공간으로 현재 수행 중인 JVM 명령어 주소를 가지게 된다.

2. JVM 스택 영역

   - 프로그램의 실행 과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
   - 메소드의 매개변수, 지역 변수 등 메소드의 정보를 저장한다.

3. Natvie Method Stack

   - Java외의 언어로 작성된 네이티브 코드를 위한 영역이다.
   - 자바 프로그램이 컴파일 되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. 

4. Method Area(Class Area, Static Area)

   - 클래스 정보를 처음 메모리 공간에 올릴 때, 초기화 되는 대상을 저장하기 위한 메모리 공간.
   - 모든 쓰레드가 **공유하는 메모리 영역**이다. 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관한다.
   - Runtime Constant Pool이라는 것이 존재하며, 이는 별도의 관리 영역으로 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행한다. (각 클래스와 인터페이스의 상수, 메소드와 필드에 대한 모든 레퍼런스를 담고 있는 테이블이다.)
   - Java 7부터 String Constant Pool은 Heap 영역으로 변경되어 GC의 관리 대상이 되었다.

5. Heap(힙 영역)

   - **객체**를 저장하는 가상 메모리 공간이다.
   - 런타임시 동적으로 할당하여 사용하는 영역.
   - `new` 연산자로 **생성된 객체와 배열을 저장**한다.
   - 클래스 영역에 올라온 클래스들로만 객체로 생성할 수 있으며, 세 부분으로 나눌 수 있다.
   - **GC의 관리 대상에 포함된다.**

<img src = "https://user-images.githubusercontent.com/33534771/83472881-3f8cee00-a4c3-11ea-942c-9b7aa0f4ea04.png" width = "70%" />


- New/Young 영역
  - Eden : 객체들이 최초로 생성되는 공간.
  - Survivor 0/1 : Eden에서 참조되는 객체들이 저장되는 공간. 

- Old 영역
  - New 영역에서 일정 시간 참조되고 살아남은 객체들이 저장되는 공간이다.
  - Eden 영역에서 인스턴스가 가득차게 되면 첫 번째 GC가 발생한다. (minor GC)
  - Eden 영역에 있는 값들을 Survivor 1 영역에 복사하고, 이 영역을 제외한 나머지 영역의 객체를 삭제한다.
  - Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역으로 이동한다. 이 과정을 반복하다가 살아남은 객체는 Old 영역으로 이동된다. 
<!--  - 여기서 일어나는 GC도 Major GC에 포함된다.-->
  
- Permanent Generation
  - 생성된 객체들의 주소값이 저장되는 공간이다.
  - 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우 사용된다.
  - Old 영역에서 살아남은 객체가 영원히 남아있는 곳이 아니다. 
  - 이 영역에서 발생하는 GC는 Major GC의 횟수에 포함된다.

## JDK
: Java로 소프트웨어를 개발할 수 있도록 여러 기능들을 제공하는 패키지(키트)

### JDK 구성
📌 apt : 어노테이션 툴

📌 appletviewer : 웹브라우저 없이 자바 애플릿을 실행하고 디버깅하기 위한 툴

📌 javac : 자바 컴파일러. 자바 소스파일을 바이트코드로 변환

📌 java : javac가 만든 클래스 파일을 해석 및 실행

📌 jar : 서로 관련있는 클래스 라이브러리들과 리소스를 하나의 파일로 묶어주는 툴

📌 jdb : 자바 디버깅 툴

📌 JRE(Java Runtime Enviroment) : Java가 동작하는데 필요한 JVM, 라이브러리 등 다양한 파일들을 포함한다. Java를 실행하려면 JRE를 설치해야한다!

📌 JVM(Java Virtual Machine) : Java가 실제로 동작하는 가상 환경. 이 JVM덕분에 하나의 Java프로젝트를 개발해도 여러 환경에서 원활하게 실행시킬 수 있다!

### JDK 종류

📌 Java SE : Java Platform , Standard Edition
표준 자바 플랫폼으로 표준적인 컴퓨팅 환경을 지원하기 위한 자바 가상머신 규격 및 API 집합을 포함한다.
JavaEE, JavaME는 구체적인 목적에 따라 자바 SE를 기반으로 API를 추가하거나 자바 가상머신 규격 및 API의 일부를 택하여 정의된다.

📌 Java EE : Java Platform , Enterprise Edition
JavaSE에 웹 어플리케이션 서버에서 동작하는 기능을 추가한 플랫폼
이 스펙에 따라 제품을 구현한 것을 웹 어플리케이션 서버(WAS)라 한다. ex. tomcat

📌 Java ME : Java Platform , Micro Edition
제한된 자원을 가진 휴대전화, PDA 등에서 Java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 중 하나이다.

### 결론

JavaSE는 Java가 어떠한 문법적인 구성을 가졌는지와 같은 것들을 나타내는 명세표이다. JavaSE를 기반으로 특정 기능을 구현하기 위한 JavaEE, JavaME 플랫폼도 있다.

JDK는 JavaSE와 같은 규격을 토대로 만들어진 소프트웨어 패키지이다. 이는 Java를 개발 및 실행하는 데 필요한 툴들을 제공한다.

JRE가 Java를 실행하는데 필요한 바로 그 툴이다.

## JRE
Java Runtime enviroment, 즉 자바 실행 환경 의 약자입니다. JVM이 자바프로그램을 실행시킬 때 반드시 필요한 라이브러리 및 기타 필수 파일을 가지고 있지요. 만약 자바 프로그램 개발이 아닌 단순히 자바 프로그램을 실행만 하려면 JRE만 다운받아 설치하면 됩니다. 구지 JDK를 다운 로드 받는 것은 불필요한 행위입니다. 

# PCB와 Context Switching

## PCB

- 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널의 자료구조입니다. PCB는 운영 체제가 프로세스를 표현한 것이라 할 수 있습니다.

- 운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스를 PCB라 합니다.

- 운영체제에서 프로세스는 PCB로 나타내어지며, PCB는 프로세스에 대한 중요한 정보를 가지고 있는 자료입니다. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거됩니다.


## Context Switching

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업

한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨


# 웹 서버와 WAS(CGI Servelet, Nginx)

## 웹 서버

📌 HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능을 담당한다.

📌 요청에 따라 아래의 두 가지 기능 중 적절하게 선택하여 수행한다.
기능 1)
정적인 컨텐츠 제공
WAS를 거치지 않고 바로 자원을 제공한다.
기능 2)
동적인 컨텐츠 제공을 위한 요청 전달
클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다.
클라이언트는 일반적으로 웹 브라우저를 의미한다.

📌 Web Server의 예
Ex) Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등

## WAS

### 📌 WAS의 개념
DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다.
“웹 컨테이너(Web Container)” 혹은 “서블릿 컨테이너(Servlet Container)”라고도 불린다.
Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다.
즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

 
### 📌 WAS의 역할
WAS = Web Server + Web Container
Web Server 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시되었다.
분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용된다.
주로 DB 서버와 같이 수행된다.
현재는 WAS가 가지고 있는 Web Server도 정적인 컨텐츠를 처리하는 데 있어서 성능상 큰 차이가 없다.
WAS의 주요 기능
프로그램 실행 환경과 DB 접속 기능 제공
여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
업무를 처리하는 비즈니스 로직 수행
WAS의 예
Ex) Tomcat, JBoss, Jeus, Web Sphere 등

## apache와 tomcat 설명

### 📌 apache 란?

apach란 것은 소프트웨어 단체 이름이다. 그리고 우리가 흔히 부르는 아파치서버라는 것은 이제단에서 후원하는 오픈소프 프로젝트 커뮤니티에서 만든 http웹서버를 지칭하는 말이다. (아파치 프로젝트는 웹서버 외에도 여러가지 프로젝트를 진행하고 있다고 한다. 이건 추후에 조사해볼것이다.) http 웹서버는 http 요청을 처리할 수 있는 웹서버이고, 아파치 http서버는 http요청을 처리하는 웹서버인 것이다. 클라이언트가 GET, POST, DELETE 등등의 메소드를 이용해 요청을 하면 이 프로그램이 어떤 결과를 돌려주는 기능을 한다. 아파치는 웹서버 이다!

### 📌 tomcat 이란?

tomcat은 흔히 WAS(Web Application Server)라고 말한다. WAS는 웹서버와 웹 컨테이너의 결합으로 다양한 기능을 컨테이너에 구현하여 다양한 역할을 수행할 수 있는 서버를 말한다. 클라이언트의 요청이 있을 때 내부의 프로그램을 통해 결과를 만들어내고 이것을 다시 클라이언트에 전달해주는 역할을 하는 것이 바로 웹 컨테이너 이다. 앞에서 본 아파치 웹 서버와 차이는 이 컨테이너 기능이 가능하냐의 차이가 가장 크다고 생각한다.

## 웹 서버와 WAS의 차이는?

목적이 다르다. 웹 서버는 정적인 데이터를 처리하는 서버이다. 이미지나 단순 html파일과 같은 리소스를 제공하는 서버는 웹 서버를 통하면 WAS를 이용하는 것보다 빠르고 안정적이다(왜? 다른 글 소스로 써볼까?) WAS는 동적인 데이터를 처리하는 서버이다. DB와 연결되어 데이터를 주고 받거나 프로그램으로 데이터 조작이 필요한 경우에는 WAS를 활용 해야 한다.

## CGI
- 동적 페이지를 위한 기술

- 웹 서버와 동적 컨텐츠 생성을 맡은 프로그램 사이에서 정보를 주고받는 인터페이스

- 초기 웹 프로그래밍에 사용된 기술

- 프로세스 단위로 실행되기 때문에 사용자 증가 시 급격한 성능 저하

## 확장 CGI
- 전통적인 CGI 방식의 단점 보완

- 프로세스 생성 방식의 변화로 시스템의 부하를 줄임

- ASP, PHP, Servlet/JSP 등

## 서블릿
1. 완전한 자바 파일의 형태

2. JSP와는 달리 자바 코드 안에 HTML 태그들이 포함

3. JSP 페이지는 하나의 서블릿으로 변환이 되고 다시 컴파일 되어 실행

4. 서블릿은 브라우저에 표시가 될 필요가 없지만 내부적으로 처리되어야 할 부분에 보다 유용하게 사용

## Nginx

Nginx는 경량 웹 서버입니다.
클라이언트로부터 요청을 받았을 때 요청에 맞는 정적 파일을 응답해주는 HTTP Web Server로 활용되기도 하고,
Reverse Proxy Server로 활용하여 WAS 서버의 부하를 줄일 수 있는 로드 밸런서로 활용되기도 합니다.