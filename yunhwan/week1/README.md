# 객체지향 특징

- 추상화
    - 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업 (공통점, 대표적 특징)
- 캡슐화
    - 캡슐화를 통해 객체 간 낮은 결합도를 유지할 수 있다.
    - 정보은닉
- 일반화 관계 (상속 관계)
    - 여러 객체들이 가진 공통된 특성을 하나의 개념으로 성립시키는 과정
- 다형성
    - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자 다른 방식으로 동작하는 능력

# 객체지향의 설계 원칙

객체지향의 원리를 이용하면 좀 더 유지보수와 확장이 쉬운 소프트웨어를 만들 수 있다.

### 객체지향의 5대 설계 윈칙 : SOLID

- 단일 책임 원칙 SRP (Single Responsibility Principle)
    - 모든 클래스는 `하나의 책임`만을 가진다.
    - 각 클래스는 책임을 완전히 `캡슐화` 해야 한다.
- 개방-폐쇄 원칙 OCP (Open Closed Principle)
    - 확장에는 열려있고 수정에는 닫혀있다.
        - 요구사항 변경이나 추가에도 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야만 한다.
- 리스코프 치환 원칙 LSP (Liskov Substitution Principle)
    - 자식 클래스는 언제나 부모 클래스를 대체할 수 있다.
        - But, 자식 클래스는 부모 클래스의 책임을 변경하지 않고 확장만을 수행해야 한다.
- 인터페이스 분리원칙 ISP (Interface Segregation Principle)
    - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
    - 자신이 이용하지 않는 기능 변화에 영향을 받지 않도록 설계해야 한다.
    - 즉, 인터페이스를 각 클라이언트에 특화되도록 분리시켜야만 한다.
- 의존 역전 원칙 DIP (Dependency Inversion Principle)
    - 의존 관계를 맺을 때는 변화가 많은 것보단 적은 것 또는 없는 것에 의존해야 한다.
        - 구체적인 클래스보단 인터페이스나 추상 클래스와 관계를 맺자.
    - 클래스 간 의존 관계?
        - 한 클래스가 어떤 기능을 수행할 때 다른 클래스의 서비스가 필요한 경우 (의존 관계)

# HTTP Method

> 클라이언트와 서버 사이에 이뤄지는 요청과 응답 데이터를 전송하는 방식

- GET
    - URL로 식별된 리소스를 쿼리 파라미터와 함께 서버에 요청 (리소스 조회)
    - HTTP Body부분은 비워져있다.
    - 정적 데이터는 리소스 경로로 조회, 동적 데이터는 쿼리 파라미터와 함께 조회 요청
- POST
    - 데이터 `생성/수정/삭제/전송` 시 사용된다.
    - HTTP Body 부분에 데이터를 넣어서 요청한다.
- PUT
    - 리소스 대체 (리소스의 일부분만 바뀌는 것이 아님), 파일 전송을 위해 사용
    - 리소스의 URI을 지정해줘야 한다. (POST와 차이)
- PATCH
    - 리소스 부분 변경
- DELETE
    - 파일 삭제를 위해 사용
- 이외의 메서드로는 HEAD, OPTIONS, TRACE, CONNECT 등이 있다.

# 정렬

- **거품정렬**
    - 서로 인접한 두 원소를 비교하여 조건에 맞지 않다면 서로 자리를 교환하며 정렬하는 알고리즘
        - 정렬이 진행될수록 정렬에서 제외되는 데이터가 증가한다.

- 시간복잡도 : O(n^2)
- 다른 메모리 공간을 필요로 하지 않는 `제자리 정렬 (in-place sorting)`
- 안정 정렬

- **삽입정렬**
    - 2번째 원소부터 시작하며, 현재 원소를 그 앞에 원소와 비교해 `삽입할 위치를 찾아서 정렬`해나가는 알고리즘
        - 최선의 경우 O(n)의 시간복잡도

    - 시간 복잡도 : O(n^2)
    - 제자리 정렬 & 안정 정렬
    - 선택정렬과 거품정렬에 비해 빠르다.

- **선택정렬**
    - 원소를 넣을 위치를 먼저 결정하고, `넣을 원소를 선택`하는 알고리즘
        - 두 번째 for 문 진입 전에 넣을 위치가 결정된다.

    - 시간 복잡도 : O(n^2)
    - 제자리 정렬 & **불안정 정렬**
