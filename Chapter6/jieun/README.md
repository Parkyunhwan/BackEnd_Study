# 데이터베이스 복제, 파티셔닝, 샤딩

## 데이터베이스 복제란?

디비를 master, slave로 나누어서 master의 내용을 slave에 복제
write는 분산하지 않고 read를 여러 slave에 분산
-> 단점 : write가 분산되지 않으므로 하나의 테이블에 write가 몰릴 경우 응답성 낮아짐

## Master DBMS 역할 : 

Write

웹서버로 부터 데이터 등록/수정/삭제 요청시 바이너리로그(Binarylog)를 생성하여 Slave 서버로 전달하게 됩니다

(웹서버로 부터 요청한 데이터 등록/수정/삭제 기능을 하는 DBMS로 많이 사용됩니다)
<br>
</br>

## Slave DBMS 역할 : 

Read

Master DBMS로 부터 전달받은 바이너리로그(Binarylog)를 데이터로 반영하게 됩니다

(웹서버로 부터 요청을 통해 데이터를 불러오는 DBMS로 많이 사용됩니다)

하는 이유 : 데이터 백업 / 부화 분산


## 파티셔닝(단편화)이란?
DB의 크기가 커질수록 정보의 처리량이 많아지므로 응답성이 낮아짐
-> DB를 여러대로 나누어서 운용하여 응답과 데이터를 분산
ex) X 테이블의 일부분은 A 디비, 또 다른 일부분은 B 디비에 저장

수직 단편화/ 수평 단편화로 나눔

## 샤딩(수평 단편화)이란?

하나의 테이블 안에서 튜플 별로 분리
분산된 테이블을 잘 찾아갈 수 있도록 key를 잘 설계하는 것이 중요

단점 : 여러 샤드를 넘나드는 쿼리를 실행 불가(해당 디비 내부 join만 가능)
스키마 구조를 변경할 때 DBA가 모든 샤드에 적용해줘야 함


# 힙 정렬

병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘

힙 : 최댓값이나 최솟값을 빠르게 찾아내기 위해 이진 트리를 기반으로 하는 트리

1. 최대 힙을 구성
2. 현재 힙 루트는 가장 큰 값이 존재함. 루트의 값을 마지막 요소와 바꾼 후, 힙의 사이즈 하나 줄임
3. 힙의 사이즈가 1보다 크면 위 과정 반복

### 시간 복잡도 : O(nlogn)

<br>

# 인터럽트

- 인터럽트란?

인터럽트란 CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능이다.

CPU에 인터럽트가 걸리면 CPU는 현재 수행하던 작업에 대한 정보를 저장한 후 인터럽트 서비스 루틴(ISR)을 수행한다.

인터럽트 처리를 마치면 이전에 수행하던 작업을 진행한다.
<br>
</br>
- 내부/외부 인터럽트엔 어떤 상황이 있는지

인터럽트는 크게 두개로 나뉜다.

1) 외부 인터럽트 : 입출력 장치, 타이밍 장치, 전원 등의 외부적인 요인에 의해서 발생

2) 내부 인터럽트 : 잘못된 명령이나 데이터를 사용할 때 발생하는 인터럽트
<br>
</br>

- 인터럽트 발생 시 처리 과정 설명

먼저, 실행중인 프로그램을 중단합니다.

이 때, 현재 프로그램 상태를 보관합니다. (컨텍스트 스위칭 = 문맥 교환)

이후 인터럽트 처리 루틴을 실행합니다.

다음, 인터럽트 서비스 루틴을 실행합니다.

인터럽트 요청 신호가 발생했을 때 보관한 PC의 값을 복원하여 이전 실행 위치로 돌아옵니다.

이어서 프로그램을 진행합니다.

- 인터럽트 우선 순위



동시에 여러 인터럽트가 발생하면 우선 순위를 정해서 하나씩 처리해야한다.

-> 생각하던 것과 마찬가지로 중요한 인터럽트가 우선적으로 처리 되어야한다.



우선 순위를 결정하는 방법은 소프트웨어적인 방법과 하드웨어적인 방법이 있다.



1) 소프트웨어적인 방법 : Polling(폴링) 



+ 인터럽트 요청 플래그를 차례로 검사하여 가장 높은 우선순위의 자원부터 서비스 루틴을 수행

+ 반응 시간이 느리다. -> 모든 인터럽트를 조사

+ 회로가 간단 -> 융통성

+ 별도의 하드웨어가 없기 때문에 경제적이다.



2) 하드웨어적인 방법 : Vectored Interrupt(벡터 인터럽트)



+ 인터럽트를 요청할 수 있는 장치에 버스를 직렬 또는 병렬로 연결하여, 인터럽트 요청 장치의 번호를 CPU에게 알리는 방식



- 병렬 연결 방식 : 각 장치를 개별적인 회선으로 연결, Mask Register의 비트 위치에 의해 우선순위 결정

 높은 우선순위 서비스시 낮은 우선순위 비활성화 기능



- 직렬 연결 방식(데이지 체인/Daisy Chain) : 모든 장치를 하나의 회선에 직렬 연결, 우선순위가 높은 장치 순으로 선두에 위치시켜 연결


# 추상클래스 인터페이스

## 추상 클래스 
 추상 클래스는 0개 이상의 추상 메소드(아직 구현되지 않은 메소드) 를 가지고, 일반 메소드, 일반 변수 또한 가질 수 있다.

그렇기에 인터페이스 역할도 하면서, 구현체도 가지고 있는 돌연변이 같은 클래스이다.

선언 시 키워드는 abstract 키워드를 사용한다.

extends

## 인터페이스

인터페이스는 쉽게 말하면 껍데기라고 말할 수 있고, 설계도 또는 명세라고 생각하면 된다.

모든 메소드가 추상 메소드이고, 일반 변수를 가질 수 없다. (추상 클래스와 비교해보자)

그 의미는 인터페이스를 구현한 클래스는 모든 메소드를 강제적으로 구현해야한다.

선언 시 interface 키워드를 사용한다.

implements


  - 공통점

추상 클래스, 인터페이스 모두 인스턴스화가 될 수 없다.

  - 차이점
  
  인터페이스를 상속받은 경우는 모든 메소드를 구현해줬다.

반면에 추상 클래스를 상속받은 경우는 일반 메소드가 아닌 추상 메소드만을 구현했다.

=> 추상 클래스는 키워드 그대로 확장, 상속을 의미함으로써, 물려주는 개념이 된다. (feed 메소드는 물려받았기에 구현할 필요 없다)

그렇기에 부모-자식 관계인 계층 구조를 나타낸다.

하지만 인터페이스는 상속 개념이 아닌, 동일한 동작을 위한 구현을 강제화 한다.

- 인터페이스를 사용하는 이유?

설계도라고 생각하면 된다.

하나의 규약, 즉 구체적인 약속 같은 것으로 인해 협업에 필수적이라고 볼 수 있다.

큰 프로젝트일수록 또는 개발 인원이 많을 경우 인터페이스를 통해 많은 이점을 얻게 된다.

- 추상 클래스를 사용하는 이유?

상속을 강제하기 위함이다.

부모 클래스에서 정의만 해놓고, 실제 동작은 자식 클래스에서 하게 된다.

# 서블릿, JSP

## Servlet
 Container가 이해할 수 있도록 구성된 자바코드로 이루어진 것(Html in JAVA)

## JSP(Java Server Page) 
html 기반에 자바코드를 블록화하여 삽입한 것(JAVA in Html)

## 서블릿과 JSP의 차이점

-servlet은 java 소스에 HTML코드가 삽입된다

-JSP는 반대로 HTML코드에 java코드가 삽입된다.

-Servlet Class는 컴파일과정과 등록 과정이 필요하지만 JSP는 필요없다.

-Servelt 보다는 JSP 다자인과 로직에 대한 구분이 명확해서 유지보수가 용이하다.

-간단한 로직을 구현할 때는 JSP가 더 간편하다.

-하지만 복잡한 로직을 구현할 때에는 HTML 중심의 코드가 이해하기 어렵게 만들 수 있고, 프로그래밍 언어를 모르는 사람이

실수로 중요한 코드를 건들 우려도 있다. 그리고 힘들게 개발한 로직의 유출을 막기 위해서도 Servlet 기술이 필요하게 된다.

그래서 요즘은 JSP 기술과 Servelt 기술을 혼용한 MVC 프로그래밍 방법이 권장되고 있다. 프로그램의 기능을 구현하는 복잡한


 
로직은 서블릿 클래스 안에서 기술하고 , 그 결과를 가져다가 출력하는 일만 JSP 페이지가 담당하도록 만드는 방법이다.
