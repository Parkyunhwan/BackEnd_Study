
# 1. 데이터베이스 복제 파티셔닝 샤딩

## 복제

* 개념
 : original server 와 copy server data를 싱크하는 과정 & 방법


* 방법
1. snapshot replication
- 한 server 의 내용이 다른 server 또는 동일 서버의 다른 database 로 단순 복사된다. 
 
 2. Merging replication
- 2개 이상의 database 가 한 개의 database 로 합쳐진다.
 
 3. Transactional replication
- 처음에 모든 정보를 copy 한 후에, 변화된 내용만을 계속 받아 update 한다


* 사용목적
1. 데이터 백업
2. DBMS의 부하분산 



## 파티셔닝

* 이점
- 가용성(Availability)
 : 물리적인 Partitioning으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.

- 관리용이성(Manageability)
 : 큰 Table들을 제거하여 관리를 쉽게 해준다.

- 성능(Performance)
 : 특정 DML과 Query의 성능을 향상시킴, 주로 대용량 Data Write 환경에서 효율적이다.
    많은 Insert가 있는 OLTP 시스템에서 Insert 작업들을 분리된 파티션들로 분산시켜 경합을 줄인다.
 

* 파티셔닝의 단점

- Table간의 Join에 대한 비용이 증가한다.
- 테이블과 인덱스를 별도로 파티션 할수는 없다. 테이블과 인덱스를 같이 Partitioning 하여야 한다.



# 2. 힙정렬

완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조


* 힙 정렬(heap sort) 알고리즘의 개념 요약
- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정 설명
1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
    - 내림차순을 기준으로 정렬
2. 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
3. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다

* 장점
- 시간 복잡도가 좋은편
- 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.

* 힙 정렬(heap sort)의 시간복잡도

시간복잡도를 계산한다면
힙 트리의 전체 높이가 거의 log₂n(완전 이진 트리이므로)이므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 log₂n만큼 소요된다.
요소의 개수가 n개 이므로 전체적으로 O(nlog₂n)의 시간이 걸린다.
T(n) = O(nlog₂n)

#3. 인터럽트

: 인터럽트는 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할경우 현재 실행중인 작업을 즉시 중단하고 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는것

* 내부 인터럽트
1. 하드웨어 고장(Hardware Interrupt)
- 컴퓨터 고장
- 데이터 전달 과정에서의 비트 오류
- 전원이 나간 경우
2.실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우
3. 명령어 실행 오류 : 나누기 0을 하는 경우
4. 사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우


* 외부 인터럽트
외부 인터럽트는 주로 입출력장치 에 의해 발생된다.

1. 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청
2. 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청


* 처리과정

1.프로그램 실행을 중단합니다.
2.
3. 현재의 프로그램 상태를 보존합니다.

3. 인터럽트 처리 루틴을 실행합니다.

4. 인터럽트 서비스 루틴을 실행합니다.

5, 인터럽트 요청 신호가 발생했을 때 보관한 PC의 값을 다시 PC에 저장합니다.

6.  PC의 값을 이용하여 인터럽트 발생 이전에 수행중이던 프로그램을 계속 실행합니다.



#4. 추상클래스 인터페이스
### 인터페이스

- 클래스가 아니며, 클래스와 관련이 없다.
- 추상 메소드와 상수만을 멤버로 가진다.
- 한 개의 클래스가 여러 인터페이스를 구현할 수 있다. (다중 구현 가능.)
- Java 8부터 default 메소드가 추가되었다.
  - default 키워드가 붙은 메소드는 구현할 수 있으며(일반 메소드처럼), 자식 클래스에서는 이를 오버라이딩할 수 있다.
  - 인터페이스가 변경되면 이를 구현하는 모든 클래스들이 해당 메소드를 다시 구현해야하는 번거로운 문제가 있었다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현할 수 있도록 변경되었다.
- Java 8부터 static 메소드가 추가되었다.
  - 인터페이스에 static 메소드를 선언 가능하게 함으로써, 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.
- 목적 : 구현 객체의 같은 동작을 보장하기 위해 사용한다.

### 추상클래스

- 클래스이며, 클래스와 관련이 있다. (주로 베이스 클래스로 사용)
- 추상 메소드 및 일반 메소드와 멤버도 포함할 수 있다.
- 한 개의 클래스가 여러 개의 클래스를 상속받을 수 없다. (다중 상속 불가능.)
- 상속을 받아 기능을 확장시키는 데 목적이 있다.
- 목적 : 기존의 클래스에서 공통된 부분을 추상화하여 상속하는 클래스에게 구현을 강제화한다. 메소드의 동작은 구현하는 자식 클래스로 위임한다.
- **공유의 목적**.

#5. 서블릿 jsp

## 서블릿
자바코드로 구현하고 컴파일하고 배포해야 한다.
HTML태그로 문자열(“”)스크림으로 처리해야 한다.
코드가 수정되면 다시 컴파일하고 배포해야 한다.
## JSP
키워드가 태그화 되어 서블릿에 비해 배우기 쉽다.
자바코드를 <%%>태그 안에 처리해주어야 한다.
HTML처럼 태그를 사용하여 자바코드도 사용이 가능하다.







