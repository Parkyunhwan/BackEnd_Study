## VLDB

읽기/쓰기 성능 및 저장 용량을 높이기 위한 기술을 총칭.

- 보통 파티셔닝/샤딩/복제/백업 등을 묶어서 부르는 기술

# 복제

> 동일한 데이터베이스를 여러 개 생성

- DB 다중화
- 트랜잭션 보장

목적

- 데이터 백업
- 고가용성(High Availability) → 시스템 확장 시 적합 (서버 장애 시 다른 서버 사용 가능)
- 부하 분산 (사용자 폭주 시 부하 분산)
- 읽기 성능을 높이는 기술

두 개 이상의 DBMS 시스템을 '마스터' 와 '슬레이브'로 나눠서 관리한다.
마스터 DBMS에서 슬레이브 DBMS로 SQL 쿼리 복제가 일어난다. (SELECT 쿼리는 제외)

데이터 업데이트(CUD)는 마스터에서 발생. 읽기(R)은 슬레이브에서 발생

- 마스터 DBMS 역할
    - CUD 요청 시 바이너리로그를 생성하여 Slave 서버로 전달
- 슬레이브 DBMS 역할
    - 마스터로부터 전달받은 바이너리로그를 데이터에 반영

# 파티셔닝

> 테이블을 파티션이라는 작은 단위로 나누어 관리하는 기법

DB에 저장하는 데이터의 대용량화가 가져오는 "용량 한계와 성능 저하"문제 발생

→ 인덱스를 달아도 B-Tree depth가 깊어져 비교회수가 증가하기 때문..
→ 데이터베이스를 분산 처리하여 성능 저하 방지 및 관리 용이

개념

- 큰 table이나 index를 관리하기 쉬운 partition 단위로 분할하는 것
    - 물리적으로는 분할되나 사용자 입장에서는 이를 느끼지 못함

목적

- 성능 향상
    - 필요한 파티션만 선별해서 검색, 업데이트하기 때문에 속도 개선
    - 데이터 Access 범위 줄이고 Insert작업의 경합을 줄임
- 가용성
    - 데이터 분할로 훼손 영역 감소 & 분할 영역별 백업

단점

- 테이블 간 조인 비용 증가
- 테이블과 인덱스를 따로 파티셔닝 할수 없다.

수직 파티셔닝, 수평 파티셔닝이 있음

# 샤딩

> 여러 개의 데이터베이스에 나눠서 데이터를 저장하는 기법

복제와 다른 점 : 복제는 **동일한 데이터**를 여러 대에 저장

파티셔닝과 다른 점 : 파티셔닝은 하나의 데이터베이스 안에서 나누어 관리하는 것을 지칭함

파티셔닝은 많이 쪼갤수록 계속해서 성능(읽기/쓰기)가 좋아지지 않지만
샤딩은 계속 쓰기 성능이 좋아질 수 있다. (샤드 별 분산 저장 속도가 빨라짐)

- 수평 샤딩
    - 동일한 스키마 (a-m / n - r / s - z <범위>)
- 수직 샤딩
    - 샤드 별로 다른 스키마를 가짐

# 힙 정렬

> 완전이진트리의 일종으로 최댓값과 최솟값을 빠르게 찾기위해 만들어진 자료구조

'힙'은 **반정렬 상태를** 유지한다.

- 힙 → 부모 노드의 키 값이 자식 노드의 키값보다 항상 큰 이진트리 (부모 > 자식)

### 힙의 구현

힙은 표준적으로 "배열"을 사용하여 구현할 수 있다.

구현의 편이성을 위해 인덱스는 0이아닌 1부터 사용한다.

**왼쪽 자식은 항상 (부모 인덱스 * 2)**

**오른쪽 자식은 항상 (부모 인덱스 * 2) + 1**

**부모 인덱스 = (자식 인덱스) // 2 가 된다.**

특징

- 시간 복잡도 O(nlogn)
- 전체 자료 정렬이 아닌 (최대/최소값)이 필요할 때 사용

# 인터럽트

> 프로그램 실행 중 CPU의 현재 처리를 중단한 후 다른 동작을 수행하도록 요구하는 동작

지금 하고 있는 일보다 중요한 일이 발생하면 그 일을 먼저 처리하고 하던 일을 계속하게 하는 것을 인터럽트라고 한다.

****처리과정****

인터럽트 요청 → 프로그램 저장(PC, SR)

어떤 장치에 인터럽트를 요구했는지 확인한다.

해당하는 "인터럽트 벡터 테이블"을 참고하여 "인터럽트 서비스 루틴"을 호출한다.

루틴을 수행한 후 원래 프로그램을 다시 수행한다.

### 폴링과 인터럽트

폴링은 특정할 일을 할 시기를 알기위해 일정 주기마다 계속해서 시그널을 체크해야만 한다. (비효율적)

인터럽트는 시그널이 들어온 정확한 타이밍에 처리하기 때문에 반응 시간이 빠르고 시스템 부하가 적다.

### 인터럽트의 유형

- 외부 인터럽트
    - 입출력장치, 타이머 장치, 전원 (외부 요인)
- 내부 인터럽트
    - 잘못된 명령이나 데이터 사용시 발생 (트랩)
        - 명령 실행 예외 (exception), 잘못된 명령 실행 (divide by zero, page fault, overflow 등)
- 소프트웨어 인터럽트
    - 프로그램 처리 중 명령의 요청에 의해 발생됨
    - "특정 인터럽트 명령어"에 의해 발생

# 추상클래스와 인터페이스

### 추상클래스

> 하나 이상의 추상메서드를 가지고 있는 추상클래스

일반적인 메서드도 같이 사용할 수 있음.

추상메서드는 안이 아직 구현되지 않은 abstract로 정의된 메서드를 말함

### 인터페이스

> 필요한 기능을 구현해서 정의해논 메서드들의 집합

인터페이스는 일반 변수를 가지지 못한다. 생성자를 가지지 못한다.

추상클래스는 상속받아서 **슈퍼클래스의 기능을 이용하고 확장시킴.**

****차이****

자바는 다중 상속을 지원하지 않는다. (다중 상속의 모호성)

자바는 여러 개의 인터페이스를 구현할 수 있다.

**인터페이스는 함수의 껍데기를 만들어서 그 함수의 구현을 강제함. (구현 객체의 같은 동작을 보장함)**
**해당 인터페이스를 구현한 객체들에 대해 동일한 동작을 약속함.**

추상클래스는 같은 종류나 행동들을 구현할 게 많고 계층구조를 명확히 표현할 때 효과적이다.
또한, 일반변수, 메서드도 사용할 수 있고 아직 구현하지 않아도될 메서드는 내버려둘 수 도 있다.

인터페이스 구현 클래스는 모든 메서드를 구현해야만 한다.
메서드 형태만 서로 공유해서 구현하는 상황일 때 동시 개발이 가능해 개발 시간을 단축할 수 있다. (변경 대처에 유연)

# 서블릿, JSP

## 서블릿

> 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술

### 특징

- 클라이언트의 요청에 대해 **동적으로 작동하는 웹 어플리케이션 컴포넌트**
- html을 사용하여 요청에 응답
- Java Thread를 이용하여 동작
- MVC패턴에서 Controller로 이용

웹서버가 동적인 페이지를 제공할 수 있도록 도와주는 어플리케이션을 "서플릿"이라고 한다.
동적인 페이지 생성 어플리케이션 → "CGI"

### 서블릿 동작 방식

1. 사용자가 URL을 입력하면 HTTP Request를 서블릿 컨테이너로 전송
2. ***서블릿 컨테이너***는 HttpServletRequest, HttpServletResponse객체 생성
3. web.xml을 기반으로 사용자가 요청한 URL이 **어느 서블릿에 대한 요청**인지 찾음
4. 해당 서블릿 service메서드를 호출한 후 클라이언트의 GET, POST여부에 따라 doGET(), doPOST()를 호출
5. doGET(), doPOST() 메서드는 동적페이지를 생성한 후 HttpServletResponse객체에 응답을 보냄
6. 응답이 끝나면 생성한 두 객체를 소멸시킴.

### CGI

별도로 제작된 웹서버와 프로그램간의 교환방식
클라이언트의 데이터를 환경변수로 전달하고, 프로그램의 출력 결과를 클라이언트에 전송 (동적인 페이지 생성 어플링케이션)

## 서블릿 컨테이너

> 서블릿을 관리해주는 컨테이너

서버에 서블릿은 스스로 작동하지 않으며 서블릿을  관리하는 "서블릿 컨테이너"가 필요하다.

클라이언트의 요청을 받아 응답하며 웹서버와 소켓을 통신하는 서블릿 컨테이너 → ***톰캣***

****역할****

- 웹서버와 통신 지원 (API 제공)
- 서블릿 생명주기 관리 (서블릿 클래스 인스턴스화, 호출, 가바지 컬렉션)
- 멀티쓰레드 지원 및 관리 (새로운 요청 시 자바 쓰레드 생성 및 삭제에 대한 다중 쓰레드 운영)
- 보안 관리

### JSP

> HTML코드에 자바 코드를 넣어 동적 웹페이지를 생성하는 웹 어플리케이션 도구

웹 프로그래머가 소스코드를 수정할 경우 디자인 부분을 제외하고 자바 소스코드만 수정하면 되기에 효율을 높여줌. (응답을 만들기 위해 요청을 어떻게 처리할 것인지 적은 텍스특기반의 문서)
